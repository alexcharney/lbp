
* Extracting some information on softwares used (for Methods)

#+BEGIN_SRC shell
###shell

# setup
  ml samtools star
  m1t=/sc/arion/projects/psychgen/lbp/files/m1TableForLiharska2021_updated30JUNE2021.tsv
  bmp=/sc/arion/projects/psychgen2/lbp/data/RAW/rna/bulk/fromSema4/Merged_Batches

# guinea pig
  sid=LBPSEMA4BRAIN088
  raw=`awk -v S=${sid} '$1==S {print $(NF-1)}' ${m1t}`
  bam=${raw}/RAPiD/bams/LBPSEMA4BRAIN088.bam

# star default settings
  STAR --help &> tmp

# non-default star settings 
  less ${raw}/RAPiD/star/LBPSEMA4BRAIN088.Log.out #"~RE-DEFINED" means non-default

# picard version for dup marking
  samtools view -H ${bam} | grep MarkDuplicates #VN:2.20.0-1-gc4dff1c-SNAPSHOT 

# featureCounts settings
  head -1 ${raw}/RAPiD/featureCounts/LBPSEMA4BRAIN088.primary.txt
  ### Program:featureCounts v1.6.3; 
  ### Command:"featureCounts" "-T" "12" 
  ###                         "-t" "exon" 
  ###                         "-g" "gene_id" 
  ###                         "--primary" 
  ###                         "-O" 
  ###                         "-p" 
  ###                         "-s" "2" 
  ###                         "-a" "gencode.v30.primary_assembly.annotation.gtf" 
  ###                         "--donotsort" "LBPSEMA4BRAIN088.no_filter.bam" 
  ### pretty sure this output is RAPiD and not featureCounts lingo...
  ###   looking at featureCounts website, seems this is the mapping:
  ###       -T 12      -> nthreads (default is 1)
  ###       -t exon    -> GTF.featureType="exon" (default)
  ###       -g gene_id -> GTF.attrType="gene_id" (default)

# samples per lane
  dir=/sc/arion/projects/psychgen/lbp/data/RAW/rna/bulk/fromSema4/200529_A00732_0073_AH7YHYDSXY
  find ${dir} -wholename "*fastq.gz" | tr '/' ' ' | awk '{print $13}' | tr '_' ' ' | grep R1 
  ##
  ## can see each sample is spread across the four lanes of the flow cell
  ##

#+END_SRC


* FOR SUBMISSION - stats for main text

#+NAME: misc_counts
#+BEGIN_SRC R
###R

# setup 
  rm(list=ls())
  library(data.table)
  library(readxl)

# expression data
  exdata <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")
  lbp <- exdata$livpmDE
  lbp[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1L)]

# master metadata
  file1 <- "/sc/arion/projects/psychgen/lbp/files/sema4_bulk_rna_sample_sheet/Bulk_RNA_Isolation_Mastertable_BRAINANDBLOOD.xlsx"
  ctypes <- c("text", rep("text", 14),"date","text","date","text",rep("numeric",4),"text","text")
  myna <- c("NA","na","",".","n/a","N/A","unknown","89+")
  met <- as.data.table(read_excel(file1, sheet=1, col_names = TRUE, col_types=ctypes, na=myna)) 
  nrow(met) #[1] 796
  uniqueN(met[,.(iid)]) #[1] 420
  nrow(met[extraction_rin>4 & PLATE!="NOT_SENDING"]) #[1] 779
  n535 <- met[extraction_rin>4 & PLATE!="NOT_SENDING"][!tissue %in% c("R_Blood", "L_Blood", "Skin")]
  met[extraction_rin>4 & PLATE!="NOT_SENDING"][grep("Brain|DLP", tissue)][,.N,extraction_kit]
  ##   extraction_kit   N
  ##1:         Qiagen 528
  ##2:         T_Prep   6
  ##3:              ?   1

# n bilateral
  uniqueN(n535[living=="Living"]$iid) #[1] 171
  m1 <- n535[living=="Living" & tissue=="L_Brain",.(iid, left=TRUE)]
  m2 <- n535[living=="Living" & tissue=="R_Brain",.(iid, right=TRUE)]
  mm <- merge(m1, m2, all=T)
  mm[is.na(left), left:=FALSE]
  mm[is.na(right), right:=FALSE]
  nrow(mm) #[1] 171
  nrow(mm[left==TRUE & right==TRUE]) #[1] 118
  nrow(mm[left==TRUE & right==FALSE]) #[1] 40
  nrow(mm[left==FALSE & right==TRUE]) #[1] 13
  nrow(mm[left==FALSE & right==FALSE]) #[1] 0
 

#+END_SRC

#+NAME: lbp_disease_de_correlations
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)
  library(ggplot2)
  library(ggthemes)
  library(wCorr) #v1.9.5

# lbp de results
  de <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")$livpmDE  
  de[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  de[,de.status := "Not DE"]
  de[DEG=="DEG" & LFC=="POSLFC", de.status:="Postmortem"]
  de[DEG=="DEG" & LFC=="NEGLFC", de.status:="Living"]
  de[,de.status:=factor(de.status,levels=c("Postmortem", "Living", "Not DE"))]
  lbp <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_bank_14OCT2021.RDS") # for pd de comparisons
  lb1 <- lbp$LIVPMDE_HAR
  lb2 <- lbp$LIVPMDE_COL
  lb1[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  lb2[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  lb1[,de.status := "Not DE"]
  lb2[,de.status := "Not DE"]
  lb1[DEG=="DEG" & LFC=="POSLFC", de.status:="Postmortem"]
  lb2[DEG=="DEG" & LFC=="POSLFC", de.status:="Postmortem"]
  lb1[DEG=="DEG" & LFC=="NEGLFC", de.status:="Living"]
  lb2[DEG=="DEG" & LFC=="NEGLFC", de.status:="Living"]
  lb1[,de.status:=factor(de.status,levels=c("Postmortem", "Living", "Not DE"))]
  lb2[,de.status:=factor(de.status,levels=c("Postmortem", "Living", "Not DE"))]
  lbx <- de[,.(gene, logFC.lbp=logFC, lbp.status=de.status)]
  lb1 <- lb1[,.(gene, logFC.lb1=logFC, lb1.status=de.status)]
  lb2 <- lb2[,.(gene, logFC.lb2=logFC, lb2.status=de.status)]
  lbx[,lbpcase:=0]
  lbx[,lbpctrl:=0]
  lb1[,lb1case:=0]
  lb1[,lb1ctrl:=0]
  lb2[,lb2case:=0]
  lb2[,lb2ctrl:=0]
  lbx[lbp.status=="Postmortem",lbpcase:=1]
  lbx[lbp.status=="Living",lbpctrl:=1]
  lb1[lb1.status=="Postmortem",lb1case:=1]
  lb1[lb1.status=="Living",lb1ctrl:=1]
  lb2[lb2.status=="Postmortem",lb2case:=1]
  lb2[lb2.status=="Living",lb2ctrl:=1]
  lbx[,lbp.status:=NULL]
  lb1[,lb1.status:=NULL]
  lb2[,lb2.status:=NULL]
  lbx <- merge(merge(lbx, lb1, all=T), lb2, all=T)

# disease signatures
  az1raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_alz1_de_results.RDS") #msbb
  az2raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_alz2_de_results.RDS") #rosmap
  sz1raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_scz1_de_results.RDS") #hbcc
  sz2raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_scz2_de_results.RDS") #cmc
  pd1raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_pmpd_bank_22OCT2021.RDS")$PMPDDE_HAR
  pd2raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_pmpd_bank_22OCT2021.RDS")$PMPDDE_COL 
  ap1raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpmageInteraction_01DEC2021.RDS")$pm1
  ap2raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpmageInteraction_01DEC2021.RDS")$pm2
  al1raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpmageInteraction_01DEC2021.RDS")$liv
  pd1raw[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  pd2raw[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  ap1raw[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  ap2raw[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  al1raw[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  az1raw[,az1.status:="Not DE"]
  az2raw[,az2.status:="Not DE"]
  sz1raw[,sz1.status:="Not DE"]
  sz2raw[,sz2.status:="Not DE"]
  pd1raw[,pd1.status:="Not DE"]
  pd2raw[,pd2.status:="Not DE"]
  ap1raw[,ap1.status:="Not DE"]
  ap2raw[,ap2.status:="Not DE"]
  al1raw[,al1.status:="Not DE"]
  az1raw[logFC>0 & adj.P.Val<0.05, az1.status:="ALZ"]
  az1raw[logFC<0 & adj.P.Val<0.05, az1.status:="CON"]
  az2raw[logFC>0 & adj.P.Val<0.05, az2.status:="ALZ"]
  az2raw[logFC<0 & adj.P.Val<0.05, az2.status:="CON"]
  sz1raw[logFC>0 & adj.P.Val<0.05, sz1.status:="SCZ"]
  sz1raw[logFC<0 & adj.P.Val<0.05, sz1.status:="CON"]
  sz2raw[logFC>0 & P.Value<0.05, sz2.status:="SCZ"]
  sz2raw[logFC<0 & P.Value<0.05, sz2.status:="CON"]
  pd1raw[adj.P.Val<0.05 & logFC>0, pd1.status:="PD"]
  pd1raw[adj.P.Val<0.05 & logFC<0, pd1.status:="CON"]
  pd2raw[adj.P.Val<0.05 & logFC>0, pd2.status:="PD"]
  pd2raw[adj.P.Val<0.05 & logFC<0, pd2.status:="CON"]
  ap1raw[adj.P.Val<0.05 & logFC>0, ap1.status:="AGEUP"]
  ap1raw[adj.P.Val<0.05 & logFC<0, ap1.status:="AGEDW"]
  ap2raw[adj.P.Val<0.05 & logFC>0, ap2.status:="AGEUP"]
  ap2raw[adj.P.Val<0.05 & logFC<0, ap2.status:="AGEDW"]
  al1raw[adj.P.Val<0.05 & logFC>0, al1.status:="AGEUP"]
  al1raw[adj.P.Val<0.05 & logFC<0, al1.status:="AGEDW"]
  az1 <- az1raw[,.(gene, logFC.az1=logFC, az1.status)]
  az2 <- az2raw[,.(gene, logFC.az2=logFC, az2.status)]
  sz1 <- sz1raw[,.(gene, logFC.sz1=logFC, sz1.status)]
  sz2 <- sz2raw[,.(gene, logFC.sz2=logFC, sz2.status)]
  pd1 <- pd1raw[,.(gene, logFC.pd1=logFC, pd1.status)]
  pd2 <- pd2raw[,.(gene, logFC.pd2=logFC, pd2.status)]
  ap1 <- ap1raw[,.(gene, logFC.ap1=logFC, ap1.status)]
  ap2 <- ap2raw[,.(gene, logFC.ap2=logFC, ap2.status)]
  al1 <- al1raw[,.(gene, logFC.al1=logFC, al1.status)]
  az1[,az1case:=0]
  az1[,az1ctrl:=0]
  az2[,az2case:=0]
  az2[,az2ctrl:=0]
  sz1[,sz1case:=0]
  sz1[,sz1ctrl:=0]
  sz2[,sz2case:=0]
  sz2[,sz2ctrl:=0]
  pd1[,pd1case:=0]
  pd1[,pd1ctrl:=0]
  pd2[,pd2case:=0]
  pd2[,pd2ctrl:=0]
  ap1[,ap1case:=0]
  ap1[,ap1ctrl:=0]
  ap2[,ap2case:=0]
  ap2[,ap2ctrl:=0]
  al1[,al1case:=0]
  al1[,al1ctrl:=0]
  az1[az1.status=="ALZ",az1case:=1]
  az1[az1.status=="CON",az1ctrl:=1]
  az2[az2.status=="ALZ",az2case:=1]
  az2[az2.status=="CON",az2ctrl:=1]
  sz1[sz1.status=="SCZ",sz1case:=1]
  sz1[sz1.status=="CON",sz1ctrl:=1]
  sz2[sz2.status=="SCZ",sz2case:=1]
  sz2[sz2.status=="CON",sz2ctrl:=1]
  pd1[pd1.status=="PD",pd1case:=1]
  pd1[pd1.status=="CON",pd1ctrl:=1]
  pd2[pd2.status=="PD",pd2case:=1]
  pd2[pd2.status=="CON",pd2ctrl:=1]
  ap1[ap1.status=="AGEUP",ap1case:=1]
  ap1[ap1.status=="AGEDW",ap1ctrl:=1]
  ap2[ap2.status=="AGEUP",ap2case:=1]
  ap2[ap2.status=="AGEDW",ap2ctrl:=1]
  al1[al1.status=="AGEUP",al1case:=1]
  al1[al1.status=="AGEDW",al1ctrl:=1]
  az1[,az1.status:=NULL]
  az2[,az2.status:=NULL]
  sz1[,sz1.status:=NULL]
  sz2[,sz2.status:=NULL]
  pd1[,pd1.status:=NULL]
  pd2[,pd2.status:=NULL]
  ap1[,ap1.status:=NULL]
  ap2[,ap2.status:=NULL]
  al1[,al1.status:=NULL]

# merge
  mer <- merge(merge(merge(merge(merge(merge(merge(merge(merge(lbx, 
             az1, all=T), az2, all=T), 
             sz1, all=T), sz2, all=T), 
             pd1, all=T), pd2, all=T), 
             ap1, all=T), ap2, all=T), 
             al1, all=T)

# make iterator
  elements <- grep("logFC", grep("gene", colnames(mer), invert=T, value=T), invert=T, value=T) 
  pairs <- as.data.table(t(combn(elements, 2)))
  pairs[,V3:=gsub("case|ctrl", "", V1)]
  pairs[,V4:=gsub("case|ctrl", "", V2)]
  pairs <- pairs[V3!=V4]

  ## ensure any two signatures from lbp data compared are non-overlapping with one another
  pairs <- pairs[ !(V1 %in% c("lbpcase", "lbpctrl") & V2 %in% c( "pd1case","pd1ctrl","pd2case","pd2ctrl",
                                                                "ap1case","ap1ctrl","ap2case","ap2ctrl")) ]

  ## dont need to compare most signatures to the livpm signatures that used only half the data
  pairs <- pairs[ !(V1 %in% c("lb1case", "lb1ctrl") & !V2 %in% c("pd2case","pd2ctrl","ap2case","ap2ctrl")) ]
  pairs <- pairs[ !(V1 %in% c("lb2case", "lb2ctrl") & !V2 %in% c("pd1case","pd1ctrl","ap1case","ap1ctrl")) ]
  pairs <- pairs[ !(V2 %in% c("lb1case", "lb1ctrl") & !V1 %in% c("pd2case","pd2ctrl","ap2case","ap2ctrl")) ]
  pairs <- pairs[ !(V2 %in% c("lb2case", "lb2ctrl") & !V1 %in% c("pd1case","pd1ctrl","ap1case","ap1ctrl")) ]
  pair2 <- unique(pairs[,.(V3, V4)])

# fishers tests
  myres <- c()
  for ( i in 1:nrow(pairs)) {
      cur1 <- pairs[i]$V1
      cur2 <- pairs[i]$V2
      curdata <- mer[ !is.na(get(cur1)) & !is.na(get(cur2)) ]
      curfish <- fisher.test(table(curdata[[cur1]], curdata[[cur2]]), alternative="greater")
      n1 <- sum(curdata[[cur1]]==1)
      n2 <- sum(curdata[[cur2]]==1)
      n3 <- sum(curdata[[cur1]]==1 & curdata[[cur2]]==1)
      n4 <- nrow(curdata)
      add <- data.table( dat1=cur1, dat2=cur2, or=curfish$estimate, p=curfish$p.value, 
                        ndat1=n1, ndat2=n2, nshared=n3, nbackground=n4)
      myres <- rbind(myres, add)
  }
  myres[,padj:=p.adjust(p,"fdr")]

# correlation tests
  myrs2 <- c()
  for ( i in 1:nrow(pair2)) {
      cur1 <- paste0("logFC.", pair2[i]$V3)
      cur2 <- paste0("logFC.", pair2[i]$V4)
      curdata <- mer[ !is.na(get(cur1)) & !is.na(get(cur2)) ]
      curcorr <- cor.test(curdata[[cur1]], curdata[[cur2]], method="spearman")
      n4 <- nrow(curdata)
      add <- data.table( dat1=cur1, dat2=cur2, rho=curcorr$estimate, p=curcorr$p.value, ngene=n4, datremoved=NA)
          myrs2 <- rbind(myrs2, add)
  }
  myrs2[,padj:=p.adjust(p,"fdr")]

# weighted correlations for text

  cur1 <- "logFC.lbp"
  cur2 <- "logFC.az1"
  curdat <- mer[ !is.na(get(cur1)) & !is.na(get(cur2)) ]
  weightedCorr(curdat[[cur1]], curdat[[cur2]], weights=abs(curdat[[cur2]]), method="Spearman") #[1] 0.4778704

  cur1 <- "logFC.lbp"
  cur2 <- "logFC.az2"
  curdat <- mer[ !is.na(get(cur1)) & !is.na(get(cur2)) ]
  weightedCorr(curdat[[cur1]], curdat[[cur2]], weights=abs(curdat[[cur2]]), method="Spearman") #[1] 0.3689945

  cur1 <- "logFC.lbp"
  cur2 <- "logFC.sz1"
  curdat <- mer[ !is.na(get(cur1)) & !is.na(get(cur2)) ]
  weightedCorr(curdat[[cur1]], curdat[[cur2]], weights=abs(curdat[[cur2]]), method="Spearman") #[1] 0.387616

  cur1 <- "logFC.lbp"
  cur2 <- "logFC.sz2"
  curdat <- mer[ !is.na(get(cur1)) & !is.na(get(cur2)) ]
  weightedCorr(curdat[[cur1]], curdat[[cur2]], weights=abs(curdat[[cur2]]), method="Spearman") #[1] 0.2880753

  cur1 <- "logFC.lb2"
  cur2 <- "logFC.pd1"
  curdat <- mer[ !is.na(get(cur1)) & !is.na(get(cur2)) ]
  weightedCorr(curdat[[cur1]], curdat[[cur2]], weights=abs(curdat[[cur2]]), method="Spearman") #[1] 0.7774521

  cur1 <- "logFC.lb1"
  cur2 <- "logFC.pd2"
  curdat <- mer[ !is.na(get(cur1)) & !is.na(get(cur2)) ]
  weightedCorr(curdat[[cur1]], curdat[[cur2]], weights=abs(curdat[[cur2]]), method="Spearman") #[1] 0.5310597

# fishers test for text

  myres[dat1 %in% c("lbpcase", "lb1case", "lb2case")][dat2 %in% c("pd1case","sz1case","az1case","pd2case","az2case","sz2case")]
  ##      dat1    dat2       or             p ndat1 ndat2 nshared nbackground          padj
  ##1: lbpcase az1case 7.067712  3.484094e-48  7131   274     222       18622  2.986367e-47
  ##2: lbpcase az2case 2.820378  2.577134e-63  6898  1155     734       17291  3.568339e-62
  ##3: lbpcase sz1case 3.409162  1.458128e-56  6802   726     485       17745  1.381384e-55
  ##4: lbpcase sz2case 1.967305  3.461573e-27  6910  1088     587       18028  1.947135e-26
  ##5: lb1case pd2case 4.032643 3.180285e-246  7038  2763    1697       21635 1.144903e-244
  ##6: lb2case pd1case 9.559805  0.000000e+00  7474  4981    3678       21635  0.000000e+00
  
   myres[dat1 %in% c("lbpctrl", "lb1ctrl", "lb2ctrl")][dat2 %in% c("pd1ctrl","sz1ctrl","az1ctrl","pd2ctrl","az2ctrl","sz2ctrl")]
  ##      dat1    dat2        or             p ndat1 ndat2 nshared nbackground          padj
  ##1: lbpctrl az1ctrl  8.479173  1.862639e-60  7746   322     275       18622  1.972206e-59
  ##2: lbpctrl az2ctrl  3.287161  1.560609e-62  7033   871     592       17291  1.755685e-61
  ##3: lbpctrl sz1ctrl  1.802735  1.884499e-13  7438   641     359       17745  8.273412e-13
  ##4: lbpctrl sz2ctrl  1.457805  1.910986e-09  7491  1055     531       18028  6.744657e-09
  ##5: lb1ctrl pd2ctrl  4.570160 1.157842e-244  8165  2312    1620       21635 3.473525e-243
  ##6: lb2ctrl pd1ctrl 10.603326  0.000000e+00  8586  4949    3970       21635  0.000000e+00

  myres[dat1 %in% c("lbpcase", "lb1case", "lb2case")][dat2 %in% c("pd1ctrl","sz1ctrl","az1ctrl","pd2ctrl","az2ctrl","sz2ctrl")]
  ##      dat1    dat2         or         p ndat1 ndat2 nshared nbackground padj
  ##1: lbpcase az1ctrl 0.06609515 1.0000000  7131   322      13       18622    1
  ##2: lbpcase az2ctrl 0.28107082 1.0000000  6898   871     143       17291    1
  ##3: lbpcase sz1ctrl 0.63796309 0.9999999  6802   641     184       17745    1
  ##4: lbpcase sz2ctrl 0.63836871 1.0000000  6910  1055     305       18028    1
  ##5: lb1case pd2ctrl 0.20617406 1.0000000  7038  2312     233       21635    1
  ##6: lb2case pd1ctrl 0.06722928 1.0000000  7474  4949     242       21635    1

  myres[dat1 %in% c("lbpctrl", "lb1ctrl", "lb2ctrl")][dat2 %in% c("pd1case","sz1case","az1case","pd2case","az2case","sz2case")]
  ##      dat1    dat2         or p ndat1 ndat2 nshared nbackground padj
  ##1: lbpctrl az1case 0.13822197 1  7746   274      25       18622    1
  ##2: lbpctrl az2case 0.35090359 1  7033  1155     235       17291    1
  ##3: lbpctrl sz1case 0.26521321 1  7438   726     121       17745    1
  ##4: lbpctrl sz2case 0.46520882 1  7491  1088     279       18028    1
  ##5: lb1ctrl pd2case 0.13645824 1  8165  2763     248       21635    1
  ##6: lb2ctrl pd1case 0.07344363 1  8586  4981     335       21635    1


#+END_SRC

#+NAME: pi1_values_for_sex_and_age
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)
  library(qvalue)

# sex
  sexDe <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_desex_22NOV2021.RDS")

# age
  ageDe <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpmageInteraction_01DEC2021.RDS")
  
# pi1
  1 - pi0est(sexDe$P.Value.LIV)$pi0 #[1] 0
  1 - pi0est(sexDe$P.Value.COL)$pi0 #[1] 0.3030003
  1 - pi0est(sexDe$P.Value.HAR)$pi0 #[1] 0
  1 - pi0est(ageDe$liv$P.Value)$pi0 #[1] 0.3180698
  1 - pi0est(ageDe$pm1$P.Value)$pi0 #[1] 0.3394314
  1 - pi0est(ageDe$pm2$P.Value)$pi0 #[1] 0.3319456

# ndeg for age
  nrow(ageDe$liv[adj.P.Val<0.05]) #[1] 587
  nrow(ageDe$pm1[adj.P.Val<0.05]) #[1] 452
  nrow(ageDe$pm2[adj.P.Val<0.05]) #[1] 758
  nrow(ageDe$interaction[adj.P.Val<0.05]) #[1] 707

# compare age signatures
  livpm <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")$livpmDE
  livAgeDe <- ageDe$liv
  pm1AgeDe <- ageDe$pm1
  pm2AgeDe <- ageDe$pm2
  livAgeDe[,DEG.liv:=0]
  livAgeDe[adj.P.Val<0.05,DEG.liv:=1]
  pm1AgeDe[,DEG.pm1:=0]
  pm1AgeDe[adj.P.Val<0.05,DEG.pm1:=1]
  pm2AgeDe[,DEG.pm2:=0]
  pm2AgeDe[adj.P.Val<0.05,DEG.pm2:=1]
  livpm[,DEG.lbp:=0]
  livpm[adj.P.Val<0.05,DEG.lbp:=1]
  livpm <- merge(livpm, livAgeDe[,.(gene,DEG.liv, logFC.liv=logFC)], by="gene") 
  livpm <- merge(livpm, pm1AgeDe[,.(gene,DEG.pm1, logFC.pm1=logFC)], by="gene") 
  livpm <- merge(livpm, pm2AgeDe[,.(gene,DEG.pm2, logFC.pm2=logFC)], by="gene") 
  fisher.test(table(livpm$DEG.lbp, livpm$DEG.liv)) #0.9359319 0.5014
  fisher.test(table(livpm$DEG.lbp, livpm$DEG.pm1)) #2.107118 9.771e-08
  fisher.test(table(livpm$DEG.lbp, livpm$DEG.pm2)) #2.150332 1.283e-12


#+END_SRC


* FOR SUBMISSION - supplementary tables

#+NAME: ST1_LBP_signature
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)

# de 
  de <- readRDS("/sc/arion/projects/psychgen2/lbp/data/RAW/rna/bulk/fromSema4/CompiledData/lbp_allBatches_RAPiD_Covs-featureCounts-vobjDream-Resids-LivPmDE_FINALModel_onlyBRAIN_518Samples_Excluding-Outliers-MislabeledSamples-BadSamples_19JUL2021.RDS")$livpmDE
  de[DEG=="DEG" & logFC>0, `DE status`:="PM DEG"]
  de[DEG=="DEG" & logFC<0, `DE status`:="LIV DEG"]
  de[DEG=="NOTDEG", `DE status`:="Not DEG"]
  de[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1L)]
  degout <- de[,.(gene, logFC, AveExpr, t, P.Value, adj.P.Val, z.std, `DE status`)]

# write
  fwrite(degout, sep='\t', na="NA", row=F, quo=F, "~/www/figures/lbp/lel2021_PRODUCTION/ST1.tsv")

# descriptions of topTable columns are at 
## https://rdrr.io/github/GabrielHoffman/variancePartition/src/R/toptable.R
## https://www.rdocumentation.org/packages/limma/versions/3.28.14/topics/toptable
#logFC: estimate of the log2-fold-change corresponding to the effect in the linear model fit
#AveExpr: average log2-expression for the gene
#t: moderated t-statistic
#P.Value: raw p-value
#adj.P.Value: adjusted p-value or q-value
#z.std: the p-value transformed into a signed z-score

#+END_SRC

#+NAME: ST2_KEGG
#+BEGIN_SRC R

# setup
  rm(list=ls())
  library(data.table)
  
# kegg results
  keg <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_keggResults.RDS")[de=="livpm"][nkegg>=10]
  keg[is.na(SuperPathwayStringB),SuperPathwayString:=SuperPathwayStringA]
  keg[!is.na(SuperPathwayStringB),SuperPathwayString:=paste(SuperPathwayStringA, SuperPathwayStringB, sep=": ")]
  keg[,SuperPathwayCode:=tstrsplit(awcid, split="|", fixed=T, keep=2L)]
  keg[,KoReferencePathwayCode:=tstrsplit(awcid, split="|", fixed=T, keep=3L)]
  keg[,SuperPathway:=paste(SuperPathwayString, SuperPathwayCode, sep="|")]
  keg[,KoReferencePathway:=paste(KoReferencePathwayStringA, KoReferencePathwayCode, sep="|")]
  keg[direction=="down",`LIV-PM DEGs`:="LIV DEGs"]
  keg[direction=="up",`LIV-PM DEGs`:="PM DEGs"]

# indicate if in fig2b
  kg2 <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_keggResults_FORFIGURE.RDS")[[1]][,.(awcid, de)]
  kg2[de=="Living",`LIV-PM DEGs`:="LIV DEGs"]
  kg2[de=="Postmortem",`LIV-PM DEGs`:="PM DEGs"]
  kg2[,de:=NULL]
  kg2[,`In Figure 2B`:=TRUE]
  keg <- merge(keg, kg2, all=T)
  keg[is.na(`In Figure 2B`), `In Figure 2B`:=FALSE]

# output for paper
  kegout <- keg[,.( `Top Level Category [TopLevelString]`=TopLevelString,
                   `Parent Category [SuperPathwayString|SuperPathwayCode]`=SuperPathway,
                   `Set [KoReferencePathwayString|KoReferencePathwayCode]`=KoReferencePathway, 
                   `LIV-PM DEGs`, 
                   `Number of DEGs`=ndeg, 
                   `Number of genes in set`=nkegg, 
                   `Number of genes overlapping LIV-PM DEGs and KEGG set`=nintersect, 
                   `Odds Ratio`=or, 
                   `Adjusted p-value`=padj, 
                   `In Figure 2B`)]

# write
  fwrite(kegout, sep='\t', na="NA", row=F, quo=F, "~/www/figures/lbp/lel2021_PRODUCTION/FORSUBMISSION/ST2_KEGG.tsv")


#+END_SRC

#+NAME: ST3_CEN
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)

# read in lbp data
  lbp <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")

# coexpression data
  cenList <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_subsets.RDS")
  cenList$livNonPD <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_livnonpd.RDS") 

# combine
  st5 <- merge(merge(merge(merge(merge( 
            cenList[["harvardControl"]][,.(Gene=gene, `PM1 Controls`=module)],
            cenList[["columbiaControl"]][,.(Gene=gene, `PM2 Controls`=module)] ),
            cenList[["harvardPD"]][,.(Gene=gene, `PM1 PD`=module)] ),
            cenList[["columbiaPD"]][,.(Gene=gene, `PM2 PD`=module)] ),
            cenList[["livPD"]][,.(Gene=gene, `LIV PD`=module)] ),
            cenList[["livNonPD"]][,.(Gene=gene, `LIV Non-PD`=module)] )
  st5[,Gene:=tstrsplit(Gene, split=".", fixed=T, keep=1L)]

# alpha syniclein 
  st5[Gene=="ENSG00000145335"][["LIV PD"]] #[1] "mediumorchid" (aka LIVPD29)

# write
  fwrite(st5, sep='\t', na="NA", row=F, quo=F, "~/www/figures/lbp/lel2021_PRODUCTION/ST5_CEN.tsv")

#+END_SRC

#+NAME: ST4_ConModEnrichment
#+BEGIN_SRC R
# setup 
  rm(list=ls())
  library(data.table)
  library(ggplot2)
  library(ggthemes)
  library(seriation)
  library(gridExtra)
  library(grid)
  library(cowplot)
  source("/hpc/users/charna02/www/figures/lbp/lel2021_PRODUCTION/FIGURE_FUNCTIONS.r")

# read in lbp data
  lbp <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")

# coexpression data
  cenList <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_subsets.RDS")
  cenList$livNonPD <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_livnonpd.RDS") 
  cenFish <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_subsets_overlap_withLivNonpd.RDS")
  cenCombos <- as.data.table(t(combn(names(cenList), 2) ))
  cenListSize <- lapply(cenList, function(x) x[,.N,module][order(N)])
  for (i in 1:length(cenListSize)) cenListSize[[i]][,SIZE := floor( 1 + 2 * (.I-1) / .N)]

# kegg data 
  keg <- fread("/sc/arion/projects/psychgen/lbp/resources/kegg/hsa00001_noheader_PARSED_MAPPED2ENSEMBL.tsv")
  keg[,awcid:=paste(TopLevelString,SuperPathwayCode,KoReferencePathwayCode,sep="|")]
  keg.nogene <- unique(keg[,.(awcid, TopLevelString,SuperPathwayStringA,SuperPathwayStringB,KoReferencePathwayStringA)])
  kgLst <- split(unique(keg[,.(awcid,gene)]), by="awcid")
  kgLst <- lapply(kgLst, function(x) x$gene)

# best matches
  myBest <- c()
  for (i in 1:nrow(cenCombos)){
      print(i)
      c1 <- cenCombos[i]$V1
      c2 <- cenCombos[i]$V2
      mod <- list( unique(cenList[[c1]]$module), unique(cenList[[c2]]$module) )
      names(mod) <- c(c1, c2)
      for (j in c(c1, c2)){
          if (j==c1) other <- c2
          if (j==c2) other <- c1
          for (k in mod[[j]]){
              if (j==c1){
                  cur <- cenFish[cen1==j & cen2==other & mod1==k][order(fisher.p)][1]
                  idx.cen <- j
                  com.cen <- other
                  idx.mod <- k
                  com.mod <- cur$mod2
                  idx.mod.size <- cur$mod1.size
                  com.mod.size <- cur$mod2.size
              } else {
                  cur <- cenFish[cen2==j & cen1==other & mod2==k][order(fisher.p)][1]
                  idx.cen <- j
                  com.cen <- other
                  idx.mod <- k
                  com.mod <- cur$mod1
                  idx.mod.size <- cur$mod2.size
                  com.mod.size <- cur$mod1.size
              }
              add <- data.table( indexCEN=idx.cen, compareCEN=com.cen,
                                indexMod=idx.mod, compareMod=com.mod,
                                indexModSize=idx.mod.size, compareModSize=com.mod.size,
                                fisher.estimate=cur$fisher.estimate, fisher.p=cur$fisher.p, fisher.p.adjust=cur$fisher.p.adjust )
              myBest <- rbind(myBest, add)                       
          }            
      }
  }
  myBest[grep("har", indexCEN),indexBank:="HVD"]
  myBest[grep("col", indexCEN),indexBank:="CBA"]
  myBest[grep("liv", indexCEN),indexBank:="LBP"]
  myBest[grep("har", compareCEN),compareBank:="HVD"]
  myBest[grep("col", compareCEN),compareBank:="CBA"]
  myBest[grep("liv", compareCEN),compareBank:="LBP"]
  myBest[grep("Control", indexCEN),indexPhe:="CON"]
  myBest[grep("Control", compareCEN),comparePhe:="CON"]
  myBest[grep("PD", indexCEN),indexPhe:="PD"]
  myBest[grep("PD", compareCEN),comparePhe:="PD"]
  myBest[grep("NonPD", indexCEN),indexPhe:="NONPD"]
  myBest[grep("NonPD", compareCEN),comparePhe:="NONPD"]
  myBest[ (indexBank=="HVD" & compareBank=="LBP"), bankPair:="PM-LIV"]
  myBest[ (indexBank=="LBP" & compareBank=="HVD"), bankPair:="LIV-PM"]
  myBest[ (indexBank=="CBA" & compareBank=="LBP"), bankPair:="PM-LIV"]
  myBest[ (indexBank=="LBP" & compareBank=="CBA"), bankPair:="LIV-PM"]
  myBest[ (indexBank=="HVD" & compareBank=="CBA") | (indexBank=="CBA" & compareBank=="HVD"), bankPair:="PM-PM"]
  myBest[ (indexBank=="HVD" & compareBank=="HVD") | (indexBank=="CBA" & compareBank=="CBA"), bankPair:="PM-PM"]
  myBest[ (indexBank=="LBP" & compareBank=="LBP"), bankPair:="LIV-LIV"]
  myBest[ (indexPhe=="CON" & comparePhe=="CON"), phePair:="CON-CON"]
  myBest[ (indexPhe=="PD" & comparePhe=="PD"), phePair:="PD-PD"]
  myBest[ (indexPhe=="PD" & comparePhe=="CON"), phePair:="PD-CON"]
  myBest[ (indexPhe=="CON" & comparePhe=="PD"), phePair:="CON-PD"]
  myBest[ (indexPhe=="PD" & comparePhe=="NONPD"), phePair:="PD-NONPD"]
  myBest[ (indexPhe=="NONPD" & comparePhe=="PD"), phePair:="NONPD-PD"]
  myBest[ (indexPhe=="CON" & comparePhe=="NONPD"), phePair:="CON-NONPD"]
  myBest[ (indexPhe=="NONPD" & comparePhe=="CON"), phePair:="NONPD-CON"]

# identify conserved modules
  allall <- c("livPD","livNonPD","columbiaPD","harvardPD","columbiaControl", "harvardControl")
  allal2 <- c("livPD","columbiaPD","harvardPD","columbiaControl", "harvardControl")
  nogrey <- myBest[indexMod!="grey" & compareMod!="grey"]
  x1 <- findConsensusModules( stats = nogrey, nets = allall, refnet =  allall[1], cenlist = cenList)
  conmod <- x1$meta
  conmodgenes <- findConsensusModuleGenes(conmod, cenList)

# enrichment of conserved modules for lbp deg
  lvDeg <- lbp$livpmDE[DEG=="DEG" & LFC=="NEGLFC"]$gene  
  pmDeg <- lbp$livpmDE[DEG=="DEG" & LFC=="POSLFC"]$gene
  bb <- lbp$livpmDE[,.(gene, module=0, lv=0, pm=0)]
  bb[gene %in% lvDeg, lv:=1]
  bb[gene %in% pmDeg, pm:=1]
  degEnrich <- c()
  for (i in 1:nrow(conmod)){
      for (j in 1:ncol(conmod)){
          cur <- copy(bb)
          net <- colnames(conmod)[j]
          mod <- conmod[[net]][i]
          mdg <- cenList[[net]][module==mod]$gene
          cur[gene %in% mdg, module:=1]
          fish1 <- fisher.test(table(cur$module, cur$lv), alternative="greater")
          fish2 <- fisher.test(table(cur$module, cur$pm), alternative="greater")
          add <- data.table( "conservedMod"=i, "indexCEN"=net, "indexMod"=mod, 
                            "indexPmOverlap"=length(intersect(mdg, pmDeg)), 
                            "indexLvOverlap"=length(intersect(mdg, lvDeg)), 
                            "indexLvEstimate"=fish1$estimate, "indexLvPval"=fish1$p.value,
                            "indexPmEstimate"=fish2$estimate, "indexPmPval"=fish2$p.value )
          cr2 <- cur[,.(gene, deg=module)]
          cr2[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1L)]
          x <- runKegg(cr2, mod, kgLst)
          x <- merge(x, keg.nogene) 
          x <- x[TopLevelString!="Human"]
          x[,padj:=p.adjust(pval, "fdr")]
          nsig <- nrow(x[padj<0.05])
          if (nsig > 0){
              mostsig <- x[order(padj)][1]
              mostsig[is.na(SuperPathwayStringB),parent:=SuperPathwayStringA]
              mostsig[!is.na(SuperPathwayStringB),parent:=paste(SuperPathwayStringA, SuperPathwayStringB, sep=": ")]
              kgAdd <- mostsig[,.(kegTerm=KoReferencePathwayStringA, kegParent=parent, kegOR=or, kegPADJ=padj)]
          } else {
              kgAdd <- mostsig[,.(kegTerm=NA, kegParent=NA, kegOR=NA, kegPADJ=NA)]
          }
          add <- cbind(add, kgAdd)
          degEnrich <- rbind(degEnrich, add)
      }
  }
  degEnrich[,indexLvPvalAdj:=p.adjust(indexLvPval, "fdr")]
  degEnrich[,indexPmPvalAdj:=p.adjust(indexPmPval, "fdr")]
  degEnrich[,conservedMod:=paste0("module",conservedMod)]
  degEnrich[,livSig:=NULL]
  degEnrich[,pmSig:=NULL]

# format
  degEnrich[indexCEN=="harvardControl", indexCEN:="PM1 Controls"]
  degEnrich[indexCEN=="columbiaControl", indexCEN:="PM2 Controls"]
  degEnrich[indexCEN=="harvardPD", indexCEN:="PM1 PD"]
  degEnrich[indexCEN=="columbiaPD", indexCEN:="PM2 PD"]
  degEnrich[indexCEN=="livPD", indexCEN:="LIV PD"]
  degEnrich[indexCEN=="livNonPD", indexCEN:="LIV Non-PD"]

# match module names with those used in figure (its arbitrary)
  degEnrich[conservedMod=="module5", conservedMod:="CM1"] #Non-coding RNA module
  degEnrich[conservedMod=="module2", conservedMod:="CM2"] #Oxidative phosphorylation module
  degEnrich[conservedMod=="module4", conservedMod:="CM3"] #Ribosome module
  degEnrich[conservedMod=="module1", conservedMod:="CM4"] #not in figure
  degEnrich[conservedMod=="module3", conservedMod:="CM5"] #not in figure
  degEnrich[,indexPmOverlap:=NULL]
  degEnrich[,indexLvOverlap:=NULL]
  degEnrich[,indexLvPval:=NULL]
  degEnrich[,indexPmPval:=NULL]
  colnames(degEnrich) <- c("Conserved Module", "CEN", "CEN Module", 
                           "LIV DEG OR", "PM DEG OR", 
                           "KEGG Gene Set", "KEGG Parent Term", "KEGG Gene Set OR",
                           "KEGG Gene Set adjusted p-value", 
                           "LIV DEG adjusted p-value", 
                           "PM DEG adjusted p-value")


# write
  fwrite(degEnrich, sep='\t', na="NA", row=F, quo=F, "~/www/figures/lbp/lel2021_PRODUCTION/ST6_ConModEnrich.tsv")

#+END_SRC

#+NAME: ST5_ALZ_SCZ_PD_AGE_signatures
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)

# lbp sig
  de <- readRDS("/sc/arion/projects/psychgen2/lbp/data/RAW/rna/bulk/fromSema4/CompiledData/lbp_allBatches_RAPiD_Covs-featureCounts-vobjDream-Resids-LivPmDE_FINALModel_onlyBRAIN_518Samples_Excluding-Outliers-MislabeledSamples-BadSamples_19JUL2021.RDS")$livpmDE
  de[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  map <- fread("/sc/arion/projects/psychgen/lbp/files/gene_ids_ensembl2symbol_fromHUGO_10JUN2020.tsv")[,.(symbol=`Approved symbol`, gene=`Ensembl gene ID`)]
  de <- merge(de, map, by="gene", all.x=TRUE)
  de[,DEG2:=as.logical(ifelse(DEG=="DEG", "TRUE", "FALSE"))]
  de[,POSLFC:=as.logical(ifelse(LFC=="POSLFC", "TRUE", "FALSE"))]
  de[,de.status := "Not DE"]
  de[DEG=="DEG" & LFC=="POSLFC", de.status:="Postmortem"]
  de[DEG=="DEG" & LFC=="NEGLFC", de.status:="Living"]
  de[,de.status:=factor(de.status,levels=c("Postmortem", "Living", "Not DE"))]
  table(de$de.status)
  ##
  ##  Living     Not DE Postmortem 
  ##    9198       4449       7988 

# alz and scz de results
  az1raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_alz1_de_results.RDS") #msbb
  az2raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_alz2_de_results.RDS") #rosmap
  sz1raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_scz1_de_results.RDS") #hbcc
  sz2raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_scz2_de_results.RDS") #cmc
  az1 <- az1raw[,.(gene, `ALZ1 logFC`=logFC, `ALZ1 P.Value`=P.Value, `ALZ1 adj.P.Val`=adj.P.Val)]
  az2 <- az2raw[,.(gene, `ALZ2 logFC`=logFC, `ALZ2 P.Value`=P.Value, `ALZ2 adj.P.Val`=adj.P.Val)]
  sz1 <- sz1raw[,.(gene, `SCZ1 logFC`=logFC, `SCZ1 P.Value`=P.Value, `SCZ1 adj.P.Val`=adj.P.Val)]
  sz2 <- sz2raw[,.(gene, `SCZ2 logFC`=logFC, `SCZ2 P.Value`=P.Value, `SCZ2 adj.P.Val`=adj.P.Val)]
  degout <- merge(merge(merge(az1, az2, all=T), sz1, all=T), sz2, all=T)

# pd pm degs
  pdp <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_pmpd_bank_22OCT2021.RDS")
  pd1 <- pdp$PMPDDE_HAR
  pd2 <- pdp$PMPDDE_COL
  pd1[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1L)]
  pd2[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1L)]
  pd1 <- pd1[,.(gene, `PD1 logFC`=logFC, `PD1 P.Value`=P.Value, `PD1 adj.P.Val`=adj.P.Val)]
  pd2 <- pd2[,.(gene, `PD2 logFC`=logFC, `PD2 P.Value`=P.Value, `PD2 adj.P.Val`=adj.P.Val)]
  pdk <- merge(pd1, pd2, by="gene")
  degout <- merge(degout, pdk, by="gene", all=T)

# age degs
  ap1 <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpmageInteraction_01DEC2021.RDS")$pm1
  ap2 <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpmageInteraction_01DEC2021.RDS")$pm2
  al1 <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpmageInteraction_01DEC2021.RDS")$liv
  ap1[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  ap2[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  al1[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  ap1 <- ap1[,.(gene, `PM1 Age logFC`=logFC, `PM1 Age P.Value`=P.Value, `PM1 Age adj.P.Val`=adj.P.Val)]
  ap2 <- ap2[,.(gene, `PM2 Age logFC`=logFC, `PM2 Age P.Value`=P.Value, `PM2 Age adj.P.Val`=adj.P.Val)]
  al1 <- al1[,.(gene, `LIV Age logFC`=logFC, `LIV Age P.Value`=P.Value, `LIV Age adj.P.Val`=adj.P.Val)]
  age <- merge(merge(ap1, ap2, by="gene"), al1, by="gene")
  degout <- merge(degout, age, by="gene", all=T)

# combine
  degout <- merge(degout, de[,.(gene, `LIV-PM signature`=de.status)], by="gene", all=T)

# write
  fwrite(degout, sep='\t', na="NA", row=F, quo=F, "~/www/figures/lbp/lel2021_PRODUCTION/FORSUBMISSION/ST_DISEASE_AGE_SIG.tsv")

#+END_SRC

#+NAME: ST6_LBP_SCZ_ALZ_PD_AGE_overlap
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)
  library(ggplot2)
  library(ggthemes)
  library(wCorr) #v1.9.5

# lbp de results
  de <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")$livpmDE  
  de[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  de[,de.status := "Not DE"]
  de[DEG=="DEG" & LFC=="POSLFC", de.status:="Postmortem"]
  de[DEG=="DEG" & LFC=="NEGLFC", de.status:="Living"]
  de[,de.status:=factor(de.status,levels=c("Postmortem", "Living", "Not DE"))]
  lbp <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_bank_14OCT2021.RDS") # for pd de comparisons
  lb1 <- lbp$LIVPMDE_HAR
  lb2 <- lbp$LIVPMDE_COL
  lb1[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  lb2[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  lb1[,de.status := "Not DE"]
  lb2[,de.status := "Not DE"]
  lb1[DEG=="DEG" & LFC=="POSLFC", de.status:="Postmortem"]
  lb2[DEG=="DEG" & LFC=="POSLFC", de.status:="Postmortem"]
  lb1[DEG=="DEG" & LFC=="NEGLFC", de.status:="Living"]
  lb2[DEG=="DEG" & LFC=="NEGLFC", de.status:="Living"]
  lb1[,de.status:=factor(de.status,levels=c("Postmortem", "Living", "Not DE"))]
  lb2[,de.status:=factor(de.status,levels=c("Postmortem", "Living", "Not DE"))]
  lbx <- de[,.(gene, logFC.lbp=logFC, lbp.status=de.status)]
  lb1 <- lb1[,.(gene, logFC.lb1=logFC, lb1.status=de.status)]
  lb2 <- lb2[,.(gene, logFC.lb2=logFC, lb2.status=de.status)]
  lbx[,lbpcase:=0]
  lbx[,lbpctrl:=0]
  lb1[,lb1case:=0]
  lb1[,lb1ctrl:=0]
  lb2[,lb2case:=0]
  lb2[,lb2ctrl:=0]
  lbx[lbp.status=="Postmortem",lbpcase:=1]
  lbx[lbp.status=="Living",lbpctrl:=1]
  lb1[lb1.status=="Postmortem",lb1case:=1]
  lb1[lb1.status=="Living",lb1ctrl:=1]
  lb2[lb2.status=="Postmortem",lb2case:=1]
  lb2[lb2.status=="Living",lb2ctrl:=1]
  lbx[,lbp.status:=NULL]
  lb1[,lb1.status:=NULL]
  lb2[,lb2.status:=NULL]
  lbx <- merge(merge(lbx, lb1, all=T), lb2, all=T)

# alz, scz, and pd de results
  az1raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_alz1_de_results.RDS") #msbb
  az2raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_alz2_de_results.RDS") #rosmap
  sz1raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_scz1_de_results.RDS") #hbcc
  sz2raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_scz2_de_results.RDS") #cmc
  pd1raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_pmpd_bank_22OCT2021.RDS")$PMPDDE_HAR
  pd2raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_pmpd_bank_22OCT2021.RDS")$PMPDDE_COL 
  ap1raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpmageInteraction_01DEC2021.RDS")$pm1
  ap2raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpmageInteraction_01DEC2021.RDS")$pm2
  al1raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpmageInteraction_01DEC2021.RDS")$liv
  pd1raw[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  pd2raw[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  ap1raw[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  ap2raw[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  al1raw[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  az1raw[,az1.status:="Not DE"]
  az2raw[,az2.status:="Not DE"]
  sz1raw[,sz1.status:="Not DE"]
  sz2raw[,sz2.status:="Not DE"]
  pd1raw[,pd1.status:="Not DE"]
  pd2raw[,pd2.status:="Not DE"]
  ap1raw[,ap1.status:="Not DE"]
  ap2raw[,ap2.status:="Not DE"]
  al1raw[,al1.status:="Not DE"]
  az1raw[logFC>0 & adj.P.Val<0.05, az1.status:="ALZ"]
  az1raw[logFC<0 & adj.P.Val<0.05, az1.status:="CON"]
  az2raw[logFC>0 & adj.P.Val<0.05, az2.status:="ALZ"]
  az2raw[logFC<0 & adj.P.Val<0.05, az2.status:="CON"]
  sz1raw[logFC>0 & adj.P.Val<0.05, sz1.status:="SCZ"]
  sz1raw[logFC<0 & adj.P.Val<0.05, sz1.status:="CON"]
  sz2raw[logFC>0 & P.Value<0.05, sz2.status:="SCZ"]
  sz2raw[logFC<0 & P.Value<0.05, sz2.status:="CON"]
  pd1raw[adj.P.Val<0.05 & logFC>0, pd1.status:="PD"]
  pd1raw[adj.P.Val<0.05 & logFC<0, pd1.status:="CON"]
  pd2raw[adj.P.Val<0.05 & logFC>0, pd2.status:="PD"]
  pd2raw[adj.P.Val<0.05 & logFC<0, pd2.status:="CON"]
  ap1raw[adj.P.Val<0.05 & logFC>0, ap1.status:="AGEUP"]
  ap1raw[adj.P.Val<0.05 & logFC<0, ap1.status:="AGEDW"]
  ap2raw[adj.P.Val<0.05 & logFC>0, ap2.status:="AGEUP"]
  ap2raw[adj.P.Val<0.05 & logFC<0, ap2.status:="AGEDW"]
  al1raw[adj.P.Val<0.05 & logFC>0, al1.status:="AGEUP"]
  al1raw[adj.P.Val<0.05 & logFC<0, al1.status:="AGEDW"]
  az1 <- az1raw[,.(gene, logFC.az1=logFC, az1.status)]
  az2 <- az2raw[,.(gene, logFC.az2=logFC, az2.status)]
  sz1 <- sz1raw[,.(gene, logFC.sz1=logFC, sz1.status)]
  sz2 <- sz2raw[,.(gene, logFC.sz2=logFC, sz2.status)]
  pd1 <- pd1raw[,.(gene, logFC.pd1=logFC, pd1.status)]
  pd2 <- pd2raw[,.(gene, logFC.pd2=logFC, pd2.status)]
  ap1 <- ap1raw[,.(gene, logFC.ap1=logFC, ap1.status)]
  ap2 <- ap2raw[,.(gene, logFC.ap2=logFC, ap2.status)]
  al1 <- al1raw[,.(gene, logFC.al1=logFC, al1.status)]
  az1[,az1case:=0]
  az1[,az1ctrl:=0]
  az2[,az2case:=0]
  az2[,az2ctrl:=0]
  sz1[,sz1case:=0]
  sz1[,sz1ctrl:=0]
  sz2[,sz2case:=0]
  sz2[,sz2ctrl:=0]
  pd1[,pd1case:=0]
  pd1[,pd1ctrl:=0]
  pd2[,pd2case:=0]
  pd2[,pd2ctrl:=0]
  ap1[,ap1case:=0]
  ap1[,ap1ctrl:=0]
  ap2[,ap2case:=0]
  ap2[,ap2ctrl:=0]
  al1[,al1case:=0]
  al1[,al1ctrl:=0]
  az1[az1.status=="ALZ",az1case:=1]
  az1[az1.status=="CON",az1ctrl:=1]
  az2[az2.status=="ALZ",az2case:=1]
  az2[az2.status=="CON",az2ctrl:=1]
  sz1[sz1.status=="SCZ",sz1case:=1]
  sz1[sz1.status=="CON",sz1ctrl:=1]
  sz2[sz2.status=="SCZ",sz2case:=1]
  sz2[sz2.status=="CON",sz2ctrl:=1]
  pd1[pd1.status=="PD",pd1case:=1]
  pd1[pd1.status=="CON",pd1ctrl:=1]
  pd2[pd2.status=="PD",pd2case:=1]
  pd2[pd2.status=="CON",pd2ctrl:=1]
  ap1[ap1.status=="AGEUP",ap1case:=1]
  ap1[ap1.status=="AGEDW",ap1ctrl:=1]
  ap2[ap2.status=="AGEUP",ap2case:=1]
  ap2[ap2.status=="AGEDW",ap2ctrl:=1]
  al1[al1.status=="AGEUP",al1case:=1]
  al1[al1.status=="AGEDW",al1ctrl:=1]
  az1[,az1.status:=NULL]
  az2[,az2.status:=NULL]
  sz1[,sz1.status:=NULL]
  sz2[,sz2.status:=NULL]
  pd1[,pd1.status:=NULL]
  pd2[,pd2.status:=NULL]
  ap1[,ap1.status:=NULL]
  ap2[,ap2.status:=NULL]
  al1[,al1.status:=NULL]

# merge
  mer <- merge(merge(merge(merge(merge(merge(merge(merge(merge(lbx, 
             az1, all=T), az2, all=T), 
             sz1, all=T), sz2, all=T), 
             pd1, all=T), pd2, all=T), 
             ap1, all=T), ap2, all=T), 
             al1, all=T)

# make iterator
  elements <- grep("logFC", grep("gene", colnames(mer), invert=T, value=T), invert=T, value=T) 
  pairs <- as.data.table(t(combn(elements, 2)))
  pairs[,V3:=gsub("case|ctrl", "", V1)]
  pairs[,V4:=gsub("case|ctrl", "", V2)]
  pairs <- pairs[V3!=V4]

  ## ensure any two signatures from lbp data compared are non-overlapping with one another
  pairs <- pairs[ !(V1 %in% c("lbpcase", "lbpctrl") & V2 %in% c( "pd1case","pd1ctrl","pd2case","pd2ctrl",
                                                                "ap1case","ap1ctrl","ap2case","ap2ctrl")) ]

  ## dont need to compare most signatures to the livpm signatures that used only half the data
  pairs <- pairs[ !(V1 %in% c("lb1case", "lb1ctrl") & !V2 %in% c("pd2case","pd2ctrl","ap2case","ap2ctrl")) ]
  pairs <- pairs[ !(V1 %in% c("lb2case", "lb2ctrl") & !V2 %in% c("pd1case","pd1ctrl","ap1case","ap1ctrl")) ]
  pairs <- pairs[ !(V2 %in% c("lb1case", "lb1ctrl") & !V1 %in% c("pd2case","pd2ctrl","ap2case","ap2ctrl")) ]
  pairs <- pairs[ !(V2 %in% c("lb2case", "lb2ctrl") & !V1 %in% c("pd1case","pd1ctrl","ap1case","ap1ctrl")) ]
  pair2 <- unique(pairs[,.(V3, V4)])

# fishers tests
  myres <- c()
  for ( i in 1:nrow(pairs)) {
      cur1 <- pairs[i]$V1
      cur2 <- pairs[i]$V2
      curdata <- mer[ !is.na(get(cur1)) & !is.na(get(cur2)) ]
      curfish <- fisher.test(table(curdata[[cur1]], curdata[[cur2]]), alternative="greater")
      n1 <- sum(curdata[[cur1]]==1)
      n2 <- sum(curdata[[cur2]]==1)
      n3 <- sum(curdata[[cur1]]==1 & curdata[[cur2]]==1)
      n4 <- nrow(curdata)
      add <- data.table( dat1=cur1, dat2=cur2, or=curfish$estimate, p=curfish$p.value, 
                        ndat1=n1, ndat2=n2, nshared=n3, nbackground=n4)
      myres <- rbind(myres, add)
  }
  myres[,padj:=p.adjust(p,"fdr")]

# stats for paper
  myres[grep("lb", dat1)][grep("case", dat1)][grep("az|sz|pd", dat2)][grep("case",dat2)] #1.947135e-26
  myres[grep("lb", dat1)][grep("ctrl", dat1)][grep("az|sz|pd", dat2)][grep("ctrl",dat2)] #6.744657e-09

  ## prettify
  myres[grep("az1", dat1), `Dataset 1` := "ALZ1"]
  myres[grep("az2", dat1), `Dataset 1` := "ALZ2"]
  myres[grep("sz1", dat1), `Dataset 1` := "SCZ1"]
  myres[grep("sz2", dat1), `Dataset 1` := "SCZ2"]
  myres[grep("pd1", dat1), `Dataset 1` := "PD1"]
  myres[grep("pd2", dat1), `Dataset 1` := "PD2"]
  myres[grep("ap1", dat1), `Dataset 1` := "PM1 Age"]
  myres[grep("ap2", dat1), `Dataset 1` := "PM2 Age"]
  myres[grep("al1", dat1), `Dataset 1` := "LIV Age"]
  myres[grep("lbp", dat1), `Dataset 1` := "LIV-PM"]
  myres[grep("lb1", dat1), `Dataset 1` := "LIV-PM1"]
  myres[grep("lb2", dat1), `Dataset 1` := "LIV-PM2"]
  myres[grep("az1", dat2), `Dataset 2` := "ALZ1"]
  myres[grep("az2", dat2), `Dataset 2` := "ALZ2"]
  myres[grep("sz1", dat2), `Dataset 2` := "SCZ1"]
  myres[grep("sz2", dat2), `Dataset 2` := "SCZ2"]
  myres[grep("pd1", dat2), `Dataset 2` := "PD1"]
  myres[grep("pd2", dat2), `Dataset 2` := "PD2"]
  myres[grep("ap1", dat2), `Dataset 2` := "PM1 Age"]
  myres[grep("ap2", dat2), `Dataset 2` := "PM2 Age"]
  myres[grep("al1", dat2), `Dataset 2` := "LIV Age"]
  myres[grep("lbp", dat2), `Dataset 2` := "LIV-PM"]
  myres[grep("lb1", dat2), `Dataset 2` := "LIV-PM1"]
  myres[grep("lb2", dat2), `Dataset 2` := "LIV-PM2"]
  mycas <- c("az1case", "sz1case", "az2case", "sz2case", "pd1case", "pd2case")
  mycon <- c("az1ctrl", "sz1ctrl", "az2ctrl", "sz2ctrl", "pd1ctrl", "pd2ctrl")
  myagh <- c("ap1case", "ap2case", "al1case")
  myagl <- c("ap1ctrl", "ap2ctrl", "al1ctrl")
  myres[dat1 == "lbpcase", `DEG Direction 1` := "PM DEGs"]
  myres[dat1 == "lb1case", `DEG Direction 1` := "PM DEGs"]
  myres[dat1 == "lb2case", `DEG Direction 1` := "PM DEGs"]
  myres[dat1 == "lbpctrl", `DEG Direction 1` := "LIV DEGs"]
  myres[dat1 == "lb1ctrl", `DEG Direction 1` := "LIV DEGs"]
  myres[dat1 == "lb2ctrl", `DEG Direction 1` := "LIV DEGs"]
  myres[dat2 == "lbpcase", `DEG Direction 2` := "PM DEGs"]
  myres[dat1 == "lb1case", `DEG Direction 2` := "PM DEGs"]
  myres[dat1 == "lb2case", `DEG Direction 2` := "PM DEGs"]
  myres[dat2 == "lbpctrl", `DEG Direction 2` := "LIV DEGs"]
  myres[dat1 == "lb1ctrl", `DEG Direction 2` := "LIV DEGs"]
  myres[dat1 == "lb2ctrl", `DEG Direction 2` := "LIV DEGs"]
  myres[dat1 %in% mycas, `DEG Direction 1` := "Case DEGs"]
  myres[dat2 %in% mycas, `DEG Direction 2` := "Case DEGs"]
  myres[dat1 %in% mycon, `DEG Direction 1` := "Control DEGs"]
  myres[dat2 %in% mycon, `DEG Direction 2` := "Control DEGs"]
  myres[dat1 %in% myagh, `DEG Direction 1` := "Higher age DEGs"]
  myres[dat2 %in% myagh, `DEG Direction 2` := "Higher age DEGs"]
  myres[dat1 %in% myagl, `DEG Direction 1` := "Lower age DEGs"]
  myres[dat2 %in% myagl, `DEG Direction 2` := "Lower age DEGs"]
  myres[, `DEG Set 1` := paste(`Dataset 1`, `DEG Direction 1`, sep = " - ")]
  myres[, `DEG Set 2` := paste(`Dataset 2`, `DEG Direction 2`, sep = " - ")]
  myres[, `Dataset 1` := NULL ] 
  myres[, `Dataset 2` := NULL ] 
  myres[, `DEG Direction 1` := NULL ]
  myres[, `DEG Direction 2` := NULL ]
  myres[, dat1 := NULL ] 
  myres[, dat2 := NULL ]
  myout <- myres[,.(`DEG Set 1`,`DEG Set 2`,
                  `NDEG Set 1` = ndat1, `NDEG Set 2` = ndat2, `NDEG Shared` = nshared,  `NBACKGROUND` = nbackground,
                  `OR`=or, `p-value`=p, `Adjusted p-value`=padj)]

  ## sanity check
  livAgeVals <- unique(grep("LIV Age", myres$`DEG Set 2`, value=T))
  pmAgeVals <- unique(c(unique(grep("PM1 Age", myres$`DEG Set 1`, value=T)),
                        unique(grep("PM1 Age", myres$`DEG Set 2`, value=T)),
                        unique(grep("PM2 Age", myres$`DEG Set 1`, value=T)),
                        unique(grep("PM2 Age", myres$`DEG Set 2`, value=T))))
  myres[`DEG Set 2` %in% livAgeVals & `DEG Set 1` %in% pmAgeVals]

  ## write
  fwrite(myout, sep='\t', na="NA", row=F, quo=F, "~/www/figures/lbp/lel2021_PRODUCTION/FORSUBMISSION/ST6.tsv")

# correlation tests
  myrs2 <- c()
  for ( i in 1:nrow(pair2)) {
      cur1 <- paste0("logFC.", pair2[i]$V3)
      cur2 <- paste0("logFC.", pair2[i]$V4)
      curdata <- mer[ !is.na(get(cur1)) & !is.na(get(cur2)) ]
      curcorr <- cor.test(curdata[[cur1]], curdata[[cur2]], method="spearman")
      n4 <- nrow(curdata)
      add <- data.table( dat1=cur1, dat2=cur2, rho=curcorr$estimate, p=curcorr$p.value, ngene=n4, datremoved=NA)
          myrs2 <- rbind(myrs2, add)
  }
  myrs2[,padj:=p.adjust(p,"fdr")]

#+END_SRC

#+NAME: ST7_PD_GWAS_MODULE_KEGG_TESTS
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)
  library(stringr)

# data
  data <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_pdModuleEnrichments_pgGwasEnrichedMods_Kegg_26OCT2021.RDS")[TopLevelString!="Human"]

# module id map 
  mmap <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_pdModuleEnrichments_22OCT2021.RDS")
  mods <- unique(mmap[set=="gwas"][or>0]$conmodule)
  mmap <- mmap[conmodule %in% mods & set=="gwas" & cen=="livPD" & module %in% data$module]
  mmap[,cm:=conmodule]
  mmap[,cm:=gsub("lvmodule", "", cm)]
  mmap[,cm:=str_pad(cm, 2, pad = "0")]
  mmap[,cm:=paste0("LIVPD", cm)]
  mmap <- mmap[,.(module, cm)]
  data <- merge(data, mmap, by="module") 

# format kegg
  data[,SuperPathwayCode:=tstrsplit(awcid, split="|", fixed=T, keep=2L)]
  data[,KoReferencePathwayCode:=tstrsplit(awcid, split="|", fixed=T, keep=3L)]
  data[is.na(SuperPathwayStringB),parent:=SuperPathwayStringA]
  data[!is.na(SuperPathwayStringB),parent:=paste(SuperPathwayStringA, SuperPathwayStringB)]
  data[,`Top Level Category [TopLevelString]`:=TopLevelString]
  data[,`CEN`:="LIV PD"]
  data[,`Conserved Module`:=cm] 
  data[,`Parent Category [SuperPathwayString|SuperPathwayCode]`:=paste(parent, SuperPathwayCode, sep="|")]
  data[,`Set [KoReferencePathwayString|KoReferencePathwayCode]`:=paste(KoReferencePathwayStringA, KoReferencePathwayCode, sep="|")]
  data[,`Number of module genes`:=ndeg]
  data[,`Number of genes in set`:=nkegg]
  data[,`Number of genes overlapping module and KEGG set`:=nintersect]
  data[,`Odds Ratio`:=or]
  data[,`Adjusted p-value`:=padj]
  data <- data[,.( `CEN`,
                  `Conserved Module`,
                  `Module`=module,
                  `Top Level Category [TopLevelString]`,
                  `Parent Category [SuperPathwayString|SuperPathwayCode]`,
                  `Set [KoReferencePathwayString|KoReferencePathwayCode]`,
                  `Number of module genes`,
                  `Number of genes in set`,
                  `Number of genes overlapping module and KEGG set`,
                  `Odds Ratio`,
                  `Adjusted p-value` )]

# write
  fwrite(data, sep='\t', na="NA", row=F, quo=F, "~/www/figures/lbp/lel2021_PRODUCTION/ST7_PDGWAS_ModKeggEnrich.tsv")


#+END_SRC


* FOR SUBMISSION - f2 - "the lbp signature"

#+NAME: DONE_livpmde_primary
#+BEGIN_SRC R
##
## this is just to reproduce lora's official result
##

# setup
  rm(list=ls())
  options(stringsAsFactors=F)
  suppressMessages(library(data.table))
  suppressMessages(library(variancePartition))
  suppressMessages(library(limma))
  suppressMessages(library(edgeR))
  suppressMessages(library(Glimma))
  suppressMessages(library(BiocParallel))
  Sys.setenv(OMP_NUM_THREADS = 6)

# read in lbp data
  lbp <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")
  met <- lbp$covariates
  vob <- lbp$vobjDream

# lora's results (what we want to reproduce here)
  #officialDe <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")$livpmDE  
  officialDe <- lbp$livpmDE 
  officialDe[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  officialDe[,de.status := "Not DE"]
  officialDe[DEG=="DEG" & LFC=="POSLFC", de.status:="Postmortem"]
  officialDe[DEG=="DEG" & LFC=="NEGLFC", de.status:="Living"]
  officialDe[,de.status:=factor(de.status,levels=c("Postmortem", "Living", "Not DE"))]
  table(officialDe$de.status)
  ##
  ##  Living     Not DE Postmortem 
  ##    9198       4449       7988 

# with contrast
  form <- ~0 + dePhe + (1|mymet_sex) + mymet_rin + neuronal + RNASeqMetrics_MEDIAN_3PRIME_BIAS + 
              RNASeqMetrics_PCT_MRNA_BASES + (1|IID_ISMMS) + (1|mymet_depletionbatch) + 
              InsertSizeMetrics_MEDIAN_INSERT_SIZE + AlignmentSummaryMetrics_STRAND_BALANCE_FIRST_OF_PAIR
  met[mymet_postmortem==1,dePhe:="PM"]
  met[mymet_postmortem==0,dePhe:="LIV"]
  met <- as.data.frame(met)
  rownames(met) <- met$SAMPLE_ISMMS
  L <- getContrast(vob, form, met, c(paste0("dePhe","PM"), paste0("dePhe","LIV")))
  fitmm2 <- dream( vob, form, met, L, BPPARAM = MulticoreParam(5))
  de2 <- topTable(fitmm2, "L1", number=nrow(vob))
  de2 <- data.table(gene = rownames(de2), de2)
  de2[,de.status := "Not DE"]
  de2[adj.P.Val < 0.05 & logFC > 0 , de.status:="Postmortem"]
  de2[adj.P.Val < 0.05 & logFC < 0 , de.status:="Living"]
  de2[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  table(de2$de.status)
  ##
  ##  Living     Not DE Postmortem 
  ##    9198       4449       7988 
  cor( merge(de2, officialDe, by="gene")$logFC.x, merge(de2, officialDe, by="gene")$logFC.y ) #[1] 1

#+END_SRC

#+NAME: DONE_livpmde_wave2only
#+BEGIN_SRC R

# setup
  rm(list=ls())
  options(stringsAsFactors=F)
  suppressMessages(library(data.table))
  suppressMessages(library(variancePartition))
  suppressMessages(library(limma))
  suppressMessages(library(edgeR))
  suppressMessages(library(Glimma))
  suppressMessages(library(BiocParallel))
  Sys.setenv(OMP_NUM_THREADS = 6)

# read in lbp data
  lbp <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")
  met <- lbp$covariates
  vob <- lbp$vobjDream

# wave 1 de results
  de1 <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/batch1_de.RDS")

# define wave2 samples
  lelcov <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/batch1_de_cov.RDS")
  wave2samples <- lbp$covariates[!ISM_SEMA4 %in% lelcov$ISM_SEMA4]$SAMPLE_ISMMS
  table(met[SAMPLE_ISMMS %in% wave2samples]$mymet_postmortem)
  ##  0   1 
  ##228 187 
 
# wave2 de
  form <- ~0 + dePhe + (1|mymet_sex) + mymet_rin + neuronal + RNASeqMetrics_MEDIAN_3PRIME_BIAS + 
              RNASeqMetrics_PCT_MRNA_BASES + (1|IID_ISMMS) + (1|mymet_depletionbatch) + 
              InsertSizeMetrics_MEDIAN_INSERT_SIZE + AlignmentSummaryMetrics_STRAND_BALANCE_FIRST_OF_PAIR
  met[SAMPLE_ISMMS %in% wave2samples & mymet_postmortem==1,dePhe:="PM"]
  met[SAMPLE_ISMMS %in% wave2samples & mymet_postmortem==0,dePhe:="LIV"]
  met <- as.data.frame(met)
  rownames(met) <- met$SAMPLE_ISMMS
  L <- getContrast(vob, form, met, c(paste0("dePhe","PM"), paste0("dePhe","LIV")))
  dreamFit <- dream( vob, form, met, L, BPPARAM = MulticoreParam(5))
  de2 <- topTable(dreamFit, "L1", number=nrow(vob))
  de2 <- data.table(gene = rownames(de2), de2)
  de2[,de.status := "Not DE"]
  de2[adj.P.Val < 0.05 & logFC > 0 , de.status:="Postmortem"]
  de2[adj.P.Val < 0.05 & logFC < 0 , de.status:="Living"]
  de2[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]

# compare wave1 and wave2
  mde <- merge(de1, de2, by="gene", suffixes=c(".wave1",".wave2"))
  cor.test(mde$logFC.wave1, mde$logFC.wave2, method="spearman") #rho = 0.8932873, p-value < 2.2e-16

# save
  saveRDS(mde, "/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_wave1vswave2de.RDS")

#+END_SRC

#+NAME: DONE_livpmde_by_hilo_pmi
#+BEGIN_SRC R

# setup
  rm(list=ls())
  options(stringsAsFactors=F)
  suppressMessages(library(variancePartition))
  suppressMessages(library(limma))
  suppressMessages(library(edgeR))
  suppressMessages(library(Glimma))
  suppressMessages(library(sp))
  suppressMessages(library(biomaRt))
  suppressMessages(library(gsubfn))
  suppressMessages(library(data.table))
  suppressMessages(library(sp))
  suppressMessages(library(viridis))
  suppressMessages(library(Matrix))
  suppressMessages(library(stats))
  suppressMessages(library(ggplot2))
  suppressMessages(library(ggthemes))
  suppressMessages(library(BiocParallel))
  suppressMessages(library("R.matlab"))
  suppressMessages(library(goseq))
  suppressMessages(library(topGO))
  suppressMessages(library(org.Hs.eg.db))
  suppressMessages(library(Rgraphviz))
  suppressMessages(library(rrvgo))
  Sys.setenv(OMP_NUM_THREADS = 6)
  set.seed(666)
  organism <- "org.Hs.eg.db"
  suppressMessages(library(clusterProfiler))
  suppressMessages(library(enrichplot))
  suppressMessages(library(DOSE))
  suppressMessages(library(organism, character.only = TRUE))

# read in lbp data
  lbp <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")
  met <- lbp$covariates
  vob <- lbp$vobjDream

# living samples

  ## define all living samples
  liv <- met[mymet_postmortem==0]$SAMPLE_ISMMS

  ## split into halves for harvard and columbia
  hlv <- sample(liv, size=round(length(which(met$mymet_postmortem==0))/2), replace=FALSE)
  clv <- liv[!liv %in% hlv]

  ## split the harvard half into halves for hi and lo pmi
  hl1 <- sample(hlv, size=round(length(hlv)/2), replace=FALSE)
  hl2 <- hlv[!hlv %in% hl1]

  ## split the columbia half into halves for hi and lo pmi
  cl1 <- sample(clv, size=round(length(clv)/2), replace=FALSE)
  cl2 <- clv[!clv %in% cl1]

  ## counts
  length(hl1) #[1] 69
  length(hl2) #[1] 69
  length(cl1) #[1] 68
  length(cl2) #[1] 69

# postmortem samples

  ## define harvard and columbia postmortem samples
  pmh <- met[Bank =="HARVARD", .(sid=SAMPLE_ISMMS, pmi=cold_pmi_CORRECTED)][!is.na(pmi)][order(pmi)]
  pmc <- met[Bank =="COLUMBIA", .(sid=SAMPLE_ISMMS, pmi=cold_pmi_CORRECTED)][!is.na(pmi)][order(pmi)]

  ## define pmi quartiiles for the two banks (1=lowest pmi, 4=highest pmi)
  pmh[,pmiquartile := floor( 1 + 4 * (.I-1) / .N)]
  pmc[,pmiquartile := floor( 1 + 4 * (.I-1) / .N)]

  ## define groups for hi and lo pmi in each bank
  hp1 <- pmh[pmiquartile==1]$sid
  hp2 <- pmh[pmiquartile==4]$sid
  cp1 <- pmc[pmiquartile==1]$sid
  cp2 <- pmc[pmiquartile==4]$sid

  ## counts
  length(hp1) #[1] 26
  length(hp2) #[1] 26
  length(cp1) #[1] 28
  length(cp2) #[1] 27

  ## means
  mean(pmh[pmiquartile==1]$pmi) #[1] 13.11308
  mean(pmh[pmiquartile==4]$pmi) #[1] 27.23346
  mean(pmc[pmiquartile==1]$pmi) #[1] 2.145714
  mean(pmc[pmiquartile==4]$pmi) #[1] 14.3337

# update metadata
  met[,pmide:="notassigned"]
  met[SAMPLE_ISMMS %in% hl1, pmide:="har_lopmi_LV"]
  met[SAMPLE_ISMMS %in% hl2, pmide:="har_hipmi_LV"]
  met[SAMPLE_ISMMS %in% cl1, pmide:="col_lopmi_LV"]
  met[SAMPLE_ISMMS %in% cl2, pmide:="col_hipmi_LV"]
  met[SAMPLE_ISMMS %in% hp1, pmide:="har_lopmi_PM"]
  met[SAMPLE_ISMMS %in% hp2, pmide:="har_hipmi_PM"]
  met[SAMPLE_ISMMS %in% cp1, pmide:="col_lopmi_PM"]
  met[SAMPLE_ISMMS %in% cp2, pmide:="col_hipmi_PM"]
  met[,pmide:=as.factor(pmide)]
  met <- as.data.frame(met)
  rownames(met) <- met$SAMPLE_ISMMS

# formula
  form <- ~0 + pmide + (1|mymet_sex) + mymet_rin + neuronal + RNASeqMetrics_MEDIAN_3PRIME_BIAS + 
              RNASeqMetrics_PCT_MRNA_BASES + (1|IID_ISMMS) + (1|mymet_depletionbatch) + 
              InsertSizeMetrics_MEDIAN_INSERT_SIZE + AlignmentSummaryMetrics_STRAND_BALANCE_FIRST_OF_PAIR

# sanity check
  identical(rownames(met), colnames(vob$E)) #[1] TRUE

# contrasts
  harLoCon <- getContrast(vob, form, met, c(paste0("pmide","har_lopmi_PM"), paste0("pmide","har_lopmi_LV")))
  harHiCon <- getContrast(vob, form, met, c(paste0("pmide","har_hipmi_PM"), paste0("pmide","har_hipmi_LV")))
  colLoCon <- getContrast(vob, form, met, c(paste0("pmide","col_lopmi_PM"), paste0("pmide","col_lopmi_LV")))
  colHiCon <- getContrast(vob, form, met, c(paste0("pmide","col_hipmi_PM"), paste0("pmide","col_hipmi_LV")))
  harPmCon <- getContrast(vob, form, met, c(paste0("pmide","har_hipmi_PM"), paste0("pmide","har_lopmi_PM")))
  colPmCon <- getContrast(vob, form, met, c(paste0("pmide","col_hipmi_PM"), paste0("pmide","col_lopmi_PM")))
  L <- cbind(harLoCon,harHiCon,colLoCon,colHiCon,harPmCon,colPmCon)

# de
  fitmm <- dream( vob, form, met, L, BPPARAM = MulticoreParam(5))

# format de results
  harLoDe <- topTable(fitmm, coef="harLoCon", number=nrow(vob))
  harHiDe <- topTable(fitmm, coef="harHiCon", number=nrow(vob))
  harPmDe <- topTable(fitmm, coef="harPmCon", number=nrow(vob))
  colLoDe <- topTable(fitmm, coef="colLoCon", number=nrow(vob))
  colHiDe <- topTable(fitmm, coef="colHiCon", number=nrow(vob))
  colPmDe <- topTable(fitmm, coef="colPmCon", number=nrow(vob))
  harLoDe <- data.table(gene = rownames(harLoDe), harLoDe)[order(logFC)]
  harHiDe <- data.table(gene = rownames(harHiDe), harHiDe)[order(logFC)]
  harPmDe <- data.table(gene = rownames(harPmDe), harPmDe)[order(logFC)]
  colLoDe <- data.table(gene = rownames(colLoDe), colLoDe)[order(logFC)]
  colHiDe <- data.table(gene = rownames(colHiDe), colHiDe)[order(logFC)]
  colPmDe <- data.table(gene = rownames(colPmDe), colPmDe)[order(logFC)]
  harLoDe[, DEG:="NOTDEG"]
  harHiDe[, DEG:="NOTDEG"]
  harPmDe[, DEG:="NOTDEG"]
  colLoDe[, DEG:="NOTDEG"]
  colHiDe[, DEG:="NOTDEG"]
  colPmDe[, DEG:="NOTDEG"]
  harLoDe[adj.P.Val<0.05, DEG:="DEG"]
  harHiDe[adj.P.Val<0.05, DEG:="DEG"]
  harPmDe[adj.P.Val<0.05, DEG:="DEG"]
  colLoDe[adj.P.Val<0.05, DEG:="DEG"]
  colHiDe[adj.P.Val<0.05, DEG:="DEG"]
  colPmDe[adj.P.Val<0.05, DEG:="DEG"]
  harLoDe[logFC<0, LFC:="NEGLFC"]
  harHiDe[logFC<0, LFC:="NEGLFC"]
  harPmDe[logFC<0, LFC:="NEGLFC"]
  colLoDe[logFC<0, LFC:="NEGLFC"]
  colHiDe[logFC<0, LFC:="NEGLFC"]
  colPmDe[logFC<0, LFC:="NEGLFC"]
  harLoDe[logFC>0, LFC:="POSLFC"]
  harHiDe[logFC>0, LFC:="POSLFC"]
  harPmDe[logFC>0, LFC:="POSLFC"]
  colLoDe[logFC>0, LFC:="POSLFC"]
  colHiDe[logFC>0, LFC:="POSLFC"]
  colPmDe[logFC>0, LFC:="POSLFC"]
  hl1.m <- as.data.table(rowMeans(vob$E[,hl1]), keep.rownames=T)[,.(gene=V1, har_lopmi_LV=V2)]
  hp1.m <- as.data.table(rowMeans(vob$E[,hp1]), keep.rownames=T)[,.(gene=V1, har_lopmi_PM=V2)]
  hl2.m <- as.data.table(rowMeans(vob$E[,hl2]), keep.rownames=T)[,.(gene=V1, har_hipmi_LV=V2)]
  hp2.m <- as.data.table(rowMeans(vob$E[,hp2]), keep.rownames=T)[,.(gene=V1, har_hipmi_PM=V2)]
  cl1.m <- as.data.table(rowMeans(vob$E[,cl1]), keep.rownames=T)[,.(gene=V1, col_lopmi_LV=V2)]
  cp1.m <- as.data.table(rowMeans(vob$E[,cp1]), keep.rownames=T)[,.(gene=V1, col_lopmi_PM=V2)]
  cl2.m <- as.data.table(rowMeans(vob$E[,cl2]), keep.rownames=T)[,.(gene=V1, col_hipmi_LV=V2)]
  cp2.m <- as.data.table(rowMeans(vob$E[,cp2]), keep.rownames=T)[,.(gene=V1, col_hipmi_PM=V2)]
  harLoDe <- merge(merge(harLoDe, hl1.m), hp1.m)
  harHiDe <- merge(merge(harHiDe, hl2.m), hp2.m)
  harPmDe <- merge(merge(harPmDe, hp1.m), hp2.m)
  colLoDe <- merge(merge(colLoDe, cl1.m), cp1.m)
  colHiDe <- merge(merge(colHiDe, cl2.m), cp2.m)
  colPmDe <- merge(merge(colPmDe, cp1.m), cp2.m)
  harLoDe[har_lopmi_LV>har_lopmi_PM,greaterExpression:="living"]
  harLoDe[har_lopmi_LV<har_lopmi_PM,greaterExpression:="postmortem"]
  harHiDe[har_hipmi_LV>har_hipmi_PM,greaterExpression:="living"]
  harHiDe[har_hipmi_LV<har_hipmi_PM,greaterExpression:="postmortem"]
  harPmDe[har_lopmi_PM>har_hipmi_PM,greaterExpression:="lopmi"]
  harPmDe[har_lopmi_PM<har_hipmi_PM,greaterExpression:="hipmi"]
  colLoDe[col_lopmi_LV>col_lopmi_PM,greaterExpression:="living"]
  colLoDe[col_lopmi_LV<col_lopmi_PM,greaterExpression:="postmortem"]
  colHiDe[col_hipmi_LV>col_hipmi_PM,greaterExpression:="living"]
  colHiDe[col_hipmi_LV<col_hipmi_PM,greaterExpression:="postmortem"]
  colPmDe[col_lopmi_PM>col_hipmi_PM,greaterExpression:="lopmi"]
  colPmDe[col_lopmi_PM<col_hipmi_PM,greaterExpression:="hipmi"]

# merge logFC values
  x1 <- harLoDe[,.(gene, logFC.harLo=logFC)] 
  x2 <- harHiDe[,.(gene, logFC.harHi=logFC)] 
  x3 <- harPmDe[,.(gene, logFC.harPm=logFC)]
  x4 <- colLoDe[,.(gene, logFC.colLo=logFC)]
  x5 <- colHiDe[,.(gene, logFC.colHi=logFC)]
  x6 <- colPmDe[,.(gene, logFC.colPm=logFC)]
  mx <- merge(merge(merge(merge(merge(x1, x2), x3), x4), x5), x6)
  rs1 <- cor.test(mx$logFC.harLo, mx$logFC.harHi, method="spearman")
  rs2 <- cor.test(mx$logFC.colLo, mx$logFC.colHi, method="spearman")
  rs3 <- cor.test(mx$logFC.harLo, mx$logFC.harPm, method="spearman")
  rs4 <- cor.test(mx$logFC.harHi, mx$logFC.harPm, method="spearman")
  rs5 <- cor.test(mx$logFC.colLo, mx$logFC.colPm, method="spearman")
  rs6 <- cor.test(mx$logFC.colHi, mx$logFC.colPm, method="spearman")
  rs7 <- cor.test(mx$logFC.harLo, mx$logFC.colLo, method="spearman")
  rs8 <- cor.test(mx$logFC.harHi, mx$logFC.colHi, method="spearman")
  rs9 <- cor.test(mx$logFC.harLo, mx$logFC.colHi, method="spearman")
  r10 <- cor.test(mx$logFC.harLo, mx$logFC.colPm, method="spearman")
  r11 <- cor.test(mx$logFC.harHi, mx$logFC.colPm, method="spearman")
  r12 <- cor.test(mx$logFC.colLo, mx$logFC.harPm, method="spearman")
  r13 <- cor.test(mx$logFC.colHi, mx$logFC.harPm, method="spearman")
  ad1 <- data.table(de="livpmlo_vs_livpmhi", bank="h_vs_h", rho=rs1$estimate, p=rs1$p.value)
  ad2 <- data.table(de="livpmlo_vs_livpmhi", bank="c_vs_c", rho=rs2$estimate, p=rs2$p.value)
  ad3 <- data.table(de="livpmlo_vs_pmlopmhi", bank="h_vs_h", rho=rs3$estimate, p=rs3$p.value)
  ad4 <- data.table(de="livpmhi_vs_pmlopmhi", bank="h_vs_h", rho=rs4$estimate, p=rs4$p.value)
  ad5 <- data.table(de="livpmlo_vs_pmlopmhi", bank="c_vs_c", rho=rs5$estimate, p=rs5$p.value)
  ad6 <- data.table(de="livpmhi_vs_pmlopmhi", bank="c_vs_c", rho=rs6$estimate, p=rs6$p.value)
  ad7 <- data.table(de="livpmlo_vs_livpmlo", bank="h_vs_c", rho=rs7$estimate, p=rs7$p.value)
  ad8 <- data.table(de="livpmhi_vs_livpmhi", bank="h_vs_c", rho=rs8$estimate, p=rs8$p.value)
  ad9 <- data.table(de="livpmlo_vs_livpmhi", bank="h_vs_c", rho=rs9$estimate, p=rs9$p.value)
  a10 <- data.table(de="livpmlo_vs_pmlopmhi", bank="h_vs_c", rho=r10$estimate, p=r10$p.value)
  a11 <- data.table(de="livpmhi_vs_pmlopmhi", bank="h_vs_c", rho=r11$estimate, p=r11$p.value)
  a12 <- data.table(de="livpmlo_vs_pmlopmhi", bank="c_vs_h", rho=r12$estimate, p=r12$p.value)
  a13 <- data.table(de="livpmhi_vs_pmlopmhi", bank="c_vs_h", rho=r13$estimate, p=r13$p.value)
  res <- rbind(ad1, ad2, ad3, ad4, ad5, ad6, ad7, ad8, ad9, a10, a11, a12, a13)

# save 
  saveRDS(list("har_livpm_lopmi"=harLoDe, "har_livpm_hipmi"=harHiDe, "har_pmpm"=harPmDe,
               "col_livpm_lopmi"=colLoDe, "col_livpm_hipmi"=colHiDe, "col_pmpm"=colPmDe, "res"=res),
          file="/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_diffpmi_02OCT2021.RDS")
  myres <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_diffpmi_02OCT2021.RDS")


#+END_SRC

#+NAME: DONE_livpmde_by_pd
#+BEGIN_SRC R

# setup
  rm(list=ls())
  options(stringsAsFactors=F)
  suppressMessages(library(data.table))
  suppressMessages(library(variancePartition))
  suppressMessages(library(limma))
  suppressMessages(library(edgeR))
  suppressMessages(library(Glimma))
  suppressMessages(library(BiocParallel))
  Sys.setenv(OMP_NUM_THREADS = 6)
  suppressMessages(library(sp))
  suppressMessages(library(biomaRt))
  suppressMessages(library(gsubfn))
  suppressMessages(library(viridis))
  suppressMessages(library(Matrix))
  suppressMessages(library(stats))
  suppressMessages(library(BiocParallel))
  Sys.setenv(OMP_NUM_THREADS = 6)

# read in lbp data
  lbp <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")
  met <- lbp$covariates
  vob <- lbp$vobjDream

# living samples
  lvk <- met[mymet_postmortem==0 & mymet_phe=="PD"]$SAMPLE_ISMMS
  lvc <- met[mymet_postmortem==0 & mymet_phe=="Control"]$SAMPLE_ISMMS

# postmortem samples
  pmk <- met[mymet_postmortem==1 & mymet_phe=="PD"]$SAMPLE_ISMMS
  pmc <- met[mymet_postmortem==1 & mymet_phe=="Control"]$SAMPLE_ISMMS

# counts
  length(lvk) #[1] 220
  length(lvc) #[1] 55
  length(pmk) #[1] 132
  length(pmc) #[1] 111

# update metadata
  met[,pdde:="notassigned"]
  met[SAMPLE_ISMMS %in% lvk, pdde:="LIVPMDE_PD_LV"]
  met[SAMPLE_ISMMS %in% pmk, pdde:="LIVPMDE_PD_PM"]
  met[SAMPLE_ISMMS %in% lvc, pdde:="LIVPMDE_CN_LV"]
  met[SAMPLE_ISMMS %in% pmc, pdde:="LIVPMDE_CN_PM"]
  met[,pdde:=as.factor(pdde)]
  met <- as.data.frame(met)
  rownames(met) <- met$SAMPLE_ISMMS

# formula
  form <- ~0 + pdde + (1|mymet_sex) + mymet_rin + neuronal + RNASeqMetrics_MEDIAN_3PRIME_BIAS + 
              RNASeqMetrics_PCT_MRNA_BASES + (1|IID_ISMMS) + (1|mymet_depletionbatch) + 
              InsertSizeMetrics_MEDIAN_INSERT_SIZE + AlignmentSummaryMetrics_STRAND_BALANCE_FIRST_OF_PAIR

# sanity check
  identical(rownames(met), colnames(vob$E)) #[1] TRUE

# contrasts
  caseCon <- getContrast(vob, form, met, c(paste0("pdde","LIVPMDE_PD_PM"), paste0("pdde","LIVPMDE_PD_LV")))
  ctrlCon <- getContrast(vob, form, met, c(paste0("pdde","LIVPMDE_CN_PM"), paste0("pdde","LIVPMDE_CN_LV")))
  L <- cbind(caseCon,ctrlCon)

# de
  fitmm <- dream( vob, form, met, L, BPPARAM = MulticoreParam(5))

# format de results
  caseDe <- topTable(fitmm, coef="caseCon", number=nrow(vob))
  ctrlDe <- topTable(fitmm, coef="ctrlCon", number=nrow(vob))
  caseDe <- data.table(gene = rownames(caseDe), caseDe)[order(logFC)]
  ctrlDe <- data.table(gene = rownames(ctrlDe), ctrlDe)[order(logFC)]
  caseDe[, DEG:="NOTDEG"]
  ctrlDe[, DEG:="NOTDEG"]
  caseDe[adj.P.Val<0.05, DEG:="DEG"]
  ctrlDe[adj.P.Val<0.05, DEG:="DEG"]
  caseDe[logFC<0, LFC:="NEGLFC"]
  caseDe[logFC>0, LFC:="POSLFC"]
  ctrlDe[logFC<0, LFC:="NEGLFC"]
  ctrlDe[logFC>0, LFC:="POSLFC"]
  casel.m <- as.data.table(rowMeans(vob$E[,lvk]), keep.rownames=T)[,.(gene=V1, LIVPMDE_PD_LV=V2)]
  casep.m <- as.data.table(rowMeans(vob$E[,pmk]), keep.rownames=T)[,.(gene=V1, LIVPMDE_PD_PM=V2)]
  ctrll.m <- as.data.table(rowMeans(vob$E[,lvc]), keep.rownames=T)[,.(gene=V1, LIVPMDE_CN_LV=V2)]
  ctrlp.m <- as.data.table(rowMeans(vob$E[,pmc]), keep.rownames=T)[,.(gene=V1, LIVPMDE_CN_PM=V2)]
  caseDe <- merge(merge(caseDe, casel.m), casep.m)
  ctrlDe <- merge(merge(ctrlDe, ctrll.m), ctrlp.m)
  caseDe[LIVPMDE_PD_LV>LIVPMDE_PD_PM,greaterExpression:="living"]
  caseDe[LIVPMDE_PD_LV<LIVPMDE_PD_PM,greaterExpression:="postmortem"]
  ctrlDe[LIVPMDE_CN_LV>LIVPMDE_CN_PM,greaterExpression:="living"]
  ctrlDe[LIVPMDE_CN_LV<LIVPMDE_CN_PM,greaterExpression:="postmortem"]

# correlate logFC values
  x1 <- caseDe[,.(gene, logFC.case=logFC)] 
  x2 <- ctrlDe[,.(gene, logFC.ctrl=logFC)] 
  mx <- merge(x1, x2)
  cor.test(mx$logFC.case, mx$logFC.ctrl, method="spearman")$estimate #[1] 0.8688515

# save 
  saveRDS(list("LIVPMDE_PD"=caseDe, "LIVPMDE_CTRL"=ctrlDe), file="/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_pdctrl_14OCT2021.RDS")
  

#+END_SRC

#+NAME: DONE_livpmde_by_bank
#+BEGIN_SRC R

# setup
  rm(list=ls())
  options(stringsAsFactors=F)
  suppressMessages(library(data.table))
  suppressMessages(library(variancePartition))
  suppressMessages(library(limma))
  suppressMessages(library(edgeR))
  suppressMessages(library(Glimma))
  suppressMessages(library(BiocParallel))
  Sys.setenv(OMP_NUM_THREADS = 6)

# read in lbp data
  lbp <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")
  met <- lbp$covariates
  vob <- lbp$vobjDream

# living samples
  set.seed(666)
  liv <- met[mymet_postmortem==0]$SAMPLE_ISMMS
  lv1 <- sample(liv, round(length(liv)/2,0))
  lv2 <- liv[!liv %in% lv1]

# postmortem samples
  har <- met[mymet_postmortem==1 & mymet_bank=="Harvard"]$SAMPLE_ISMMS
  col <- met[mymet_postmortem==1 & mymet_bank=="Columbia"]$SAMPLE_ISMMS

# counts
  length(lv1) #[1] 138
  length(lv2) #[1] 137
  length(har) #[1] 104
  length(col) #[1] 126

# update metadata
  met[,de:="notassigned"]
  met[SAMPLE_ISMMS %in% lv1, de:="LIVPMDE_HAR_LV"]
  met[SAMPLE_ISMMS %in% har, de:="LIVPMDE_HAR_PM"]
  met[SAMPLE_ISMMS %in% lv2, de:="LIVPMDE_COL_LV"]
  met[SAMPLE_ISMMS %in% col, de:="LIVPMDE_COL_PM"]
  met[,de:=as.factor(de)]
  met <- as.data.frame(met)
  rownames(met) <- met$SAMPLE_ISMMS

# formula
  form <- ~0 + de + (1|mymet_sex) + mymet_rin + neuronal + RNASeqMetrics_MEDIAN_3PRIME_BIAS + 
              RNASeqMetrics_PCT_MRNA_BASES + (1|IID_ISMMS) + (1|mymet_depletionbatch) + 
              InsertSizeMetrics_MEDIAN_INSERT_SIZE + AlignmentSummaryMetrics_STRAND_BALANCE_FIRST_OF_PAIR

# sanity check
  identical(rownames(met), colnames(vob$E)) #[1] TRUE

# contrasts
  harCon <- getContrast(vob, form, met, c(paste0("de","LIVPMDE_HAR_PM"), paste0("de","LIVPMDE_HAR_LV")))
  colCon <- getContrast(vob, form, met, c(paste0("de","LIVPMDE_COL_PM"), paste0("de","LIVPMDE_COL_LV")))
  L <- cbind(harCon,colCon)

# de
  fitmm <- dream( vob, form, met, L, BPPARAM = MulticoreParam(5))

# format de results
  harDe <- topTable(fitmm, coef="harCon", number=nrow(vob))
  colDe <- topTable(fitmm, coef="colCon", number=nrow(vob))
  harDe <- data.table(gene = rownames(harDe), harDe)[order(logFC)]
  colDe <- data.table(gene = rownames(colDe), colDe)[order(logFC)]
  harDe[, DEG:="NOTDEG"]
  colDe[, DEG:="NOTDEG"]
  harDe[adj.P.Val<0.05, DEG:="DEG"]
  colDe[adj.P.Val<0.05, DEG:="DEG"]
  harDe[logFC<0, LFC:="NEGLFC"]
  harDe[logFC>0, LFC:="POSLFC"]
  colDe[logFC<0, LFC:="NEGLFC"]
  colDe[logFC>0, LFC:="POSLFC"]
  harl.m <- as.data.table(rowMeans(vob$E[,lv1]), keep.rownames=T)[,.(gene=V1, LIVPMDE_HAR_LV=V2)]
  harp.m <- as.data.table(rowMeans(vob$E[,har]), keep.rownames=T)[,.(gene=V1, LIVPMDE_HAR_PM=V2)]
  coll.m <- as.data.table(rowMeans(vob$E[,lv2]), keep.rownames=T)[,.(gene=V1, LIVPMDE_COL_LV=V2)]
  colp.m <- as.data.table(rowMeans(vob$E[,col]), keep.rownames=T)[,.(gene=V1, LIVPMDE_COL_PM=V2)]
  harDe <- merge(merge(harDe, harl.m), harp.m)
  colDe <- merge(merge(colDe, coll.m), colp.m)
  harDe[LIVPMDE_HAR_LV>LIVPMDE_HAR_PM,greaterExpression:="living"]
  harDe[LIVPMDE_HAR_LV<LIVPMDE_HAR_PM,greaterExpression:="postmortem"]
  colDe[LIVPMDE_COL_LV>LIVPMDE_COL_PM,greaterExpression:="living"]
  colDe[LIVPMDE_COL_LV<LIVPMDE_COL_PM,greaterExpression:="postmortem"]

# correlate logFC values
  x1 <- harDe[,.(gene, logFC.har=logFC)] 
  x2 <- colDe[,.(gene, logFC.col=logFC)] 
  mx <- merge(x1, x2)
  cor.test(mx$logFC.har, mx$logFC.col, method="spearman")$estimate #[1] 0.9440758

# save 
  saveRDS(list("LIVPMDE_HAR"=harDe, "LIVPMDE_COL"=colDe), file="/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_bank_14OCT2021.RDS")
  
#+END_SRC

#+NAME: DONE_parse_kegg
#+BEGIN_SRC shell
##
## downloaded on 04OCT2021 from https://www.kegg.jp/kegg-bin/show_brite?hsa00001
##

# setup
  KDR=/sc/arion/projects/psychgen/lbp/resources/kegg/
  RAW=/sc/arion/projects/psychgen/lbp/resources/kegg/hsa00001.keg
  cd ${KDR}

# remove header
  awk 'NR>4' ${RAW} | awk 'NF>1' | sed s/'B  '/'B '/g | sed s/'C    '/'C '/g | sed s/'D      '/'D '/g > hsa00001_noheader.keg

# parse
  python /sc/arion/work/charna02/scripts/lbp/parse_kegg.py
  ##
  ## writes the file: /sc/arion/projects/psychgen/lbp/resources/kegg/hsa00001_noheader_PARSED.tsv

#+END_SRC
#+BEGIN_SRC R

# setup 
  library(data.table)
  map <- fread("~/gene_ids_ensembl2symbol_fromHUGO_10JUN2020.tsv", na="", col.names=c("symbol", "gene"))[!is.na(gene) & !is.na(symbol)]

# read in kegg
  keg <- fread("/sc/arion/projects/psychgen/lbp/resources/kegg/hsa00001_noheader_PARSED.tsv")

# how good is out mapping file
  x1 <- unique(map$symbol)
  x2 <- unique(keg$GeneString)
  length(intersect(x1, x2)) / length(x2) #[1] 0.9907873 ... yay

# merge
  keg <- merge(keg, map, by.x="GeneString", by.y="symbol")

# write
  fwrite(keg, sep='\t', row=F, quo=F, na="NA", file="/sc/arion/projects/psychgen/lbp/resources/kegg/hsa00001_noheader_PARSED_MAPPED2ENSEMBL.tsv")

#+END_SRC

#+NAME: DONE_kegg_enrichment_for_livpm
#+BEGIN_SRC R

# setup
  rm(list=ls())
  options(stringsAsFactors=F)
  library(ggplot2)
  library(ggthemes)
  library(data.table)
  library(seriation)
  library(apcluster)

# read in kegg
  keg <- fread("/sc/arion/projects/psychgen/lbp/resources/kegg/hsa00001_noheader_PARSED_MAPPED2ENSEMBL.tsv")
  keg[,awcid:=paste(TopLevelString,SuperPathwayCode,KoReferencePathwayCode,sep="|")]
  keg.nogene <- unique(keg[,.(awcid, TopLevelString,SuperPathwayStringA,SuperPathwayStringB,KoReferencePathwayStringA)])
  uniqueN(keg) #[1] 49949
  uniqueN(keg[,.(awcid,gene)]) #[1] 49939
  uniqueN(keg[,.(awcid,gene,GeneString)]) #[1] 49939
  uniqueN(keg[,.(awcid,gene,GeneString,GeneCode)]) #[1] 49949 ... ok so entrez<>gene has some dups, who cares

# make list of kegg pathways to test
  kgLst <- split(unique(keg[,.(awcid,gene)]), by="awcid")
  kgLst <- lapply(kgLst, function(x) x$gene)

# kegg term similarity (for plotting)
  tmp1 <- unique(keg[,.(awcid,gene)])
  tmp1[, value:=1]
  tmp2 <- dcast( tmp1, awcid ~ gene, value.var="value", fill=0)
  tmp3 <- as.matrix(tmp2[,2:ncol(tmp2)]) 
  rownames(tmp3) <- tmp2$awcid
  table(c(tmp3))
  ##      0       1
  ##6212793   49939 ... ok good, sanity check we made this right
  kgSim <- negDistMat(tmp3)
  kgDis <- dist(kgSim)
  kgOrd <- seriate(kgDis)
  kgSim2 <- kgSim[unlist(kgOrd),unlist(kgOrd)]
  kgTermOrd <- rownames(kgSim2)

# functions for kegg
  formatForKegg <- function(dt, padj=TRUE){
      dt[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1L)]
      up <- dt[,.(gene,deg=0)]
      dw <- dt[,.(gene,deg=0)]
      if (padj){
          ug <- dt[logFC>0 & adj.P.Val<0.05]$gene
          dg <- dt[logFC<0 & adj.P.Val<0.05]$gene
      } else {
          ug <- dt[logFC>0 & P.Value<0.05]$gene
          dg <- dt[logFC<0 & P.Value<0.05]$gene
      }
      up[gene %in% ug,deg:=1]
      dw[gene %in% dg,deg:=1]
      ret <- list("up"=up, "down"=dw)
      ret
  }
  runKegg <- function(dt, dename, klist){
      out <- c()
      count <- 1
      for (i in names(klist)){
          pct <- round(100*(count/length(klist)), 0)
          if (count %% 100 == 0 ) cat(dename, pct,"%\n")
          count <- count+1
          ##cat(i,'\n')
          dt[,kegg:=0]
          dt[gene %in% klist[[i]],kegg:=1]
          n1 <- nrow(dt[deg==1])
          n2 <- nrow(dt[kegg==1])
          if (n2>0){
              n3 <- nrow(dt[deg==1 & kegg==1])
              ft <- fisher.test(table(dt$deg, dt$kegg), alternative="greater")
              or <- ft$estimate
              pv <- ft$p.value
              add <- data.table(awcid=i, ndeg=n1, nkegg=n2, nintersect=n3, or=or, pval=pv)
              out <- rbind(out, add) 
          }
      }
      out
  }

# make list of degs to test
  deLst <- list()

  ## main lbp degs
  lbp <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")$livpmDE
  deLst[["livpm"]] <- formatForKegg(lbp)

  ## lbp degs (stratified by pmi)
  others <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_diffpmi_02OCT2021.RDS")
  othernames <- grep("res", names(others), invert=T, value=T)
  for (i in othernames){ 
      if (i %in% c("har_pmpm", "col_pmpm")){
          deLst[[i]] <- formatForKegg(others[[i]], padj=FALSE)
      } else {
          deLst[[i]] <- formatForKegg(others[[i]], padj=TRUE)
      }
  }

# run kegg
  kgRes <- c()
  for (i in names(deLst)){
      for (j in names(deLst[[i]])){
          x <- runKegg(deLst[[i]][[j]], paste(i, j), kgLst)
          add <- data.table(de=i, direction=j, x)
          add <- merge(add, keg.nogene) 
          add <- add[TopLevelString!="Human"]
          add[,padj:=p.adjust(pval)]
          kgRes <- rbind(kgRes, add)
      }
  }
  nrow(kgRes[,.N,KoReferencePathwayStringA]) #[1] 310
  saveRDS(kgRes, file="/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_keggResults.RDS")

# top ten parents for liv and pm

  ## define parent terms
  kgRes[is.na(SuperPathwayStringB),parent:=SuperPathwayStringA]
  kgRes[!is.na(SuperPathwayStringB),parent:=paste(SuperPathwayStringA, SuperPathwayStringB, sep=": ")]

  ## remove terms less than 10 genes
  kgRes <- kgRes[de=="livpm" & nkegg>=10]
  nrow(kgRes[,.N,awcid]) #[1] 278
  kgResParents <- unique(kgRes$parent)
  length(kgResParents) #[1] 39

  ## find best term for each parent
  kgLv <- c()
  kgPm <- c()
  for (i in kgResParents){
      curLv <- kgRes[direction=="down" & parent==i][order(pval)]
      curPm <- kgRes[direction=="up" & parent==i][order(pval)]
      curLv[,dirParentChildIndex:=.I]
      curPm[,dirParentChildIndex:=.I]
      kgLv <- rbind(kgLv, curLv) 
      kgPm <- rbind(kgPm, curPm) 
  }
  kgLvBest <- merge(kgLv, kgLv[,list(dirParentChildIndex=min(dirParentChildIndex)),list(parent)])
  kgPmBest <- merge(kgPm, kgPm[,list(dirParentChildIndex=min(dirParentChildIndex)),list(parent)])
  nrow(kgLvBest) #[1] 39
  nrow(kgPmBest) #[1] 39
  kgLvBestSlim <- kgLvBest[,.(de="Living", term=KoReferencePathwayStringA, parent, ndeg, nkegg, nintersect, or, pval , padj,awcid)]
  kgPmBestSlim <- kgPmBest[,.(de="Postmortem", term=KoReferencePathwayStringA, parent, ndeg, nkegg, nintersect, or, pval , padj,awcid)]
  kgBestSlim <- rbind(kgLvBestSlim,kgPmBestSlim)

  ## order parent terms by or 
  parentOrder <- merge(kgBestSlim, kgBestSlim[,list(or=max(or)),list(parent)])[order(or)]$parent
  kgBestSlim[,parent:=factor(parent, levels=rev(parentOrder))]

  ## subset parent terms for being significant in either liv or pm
  pdat <- kgBestSlim[parent %in% kgBestSlim[padj<0.05]$parent]
  pdat[,isSig:=FALSE]
  pdat[padj<0.05,isSig:=TRUE]
  plabdat <- pdat[isSig==TRUE,.(de, parent, term, or, padj)]
  plabdat <- plabdat[order(parent)]
  saveRDS(list(pdat,plabdat), file="/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_keggResults_FORFIGURE.RDS")

# same terms for diff directions? no
  unique(kgRes[padj<0.05][,.(KoReferencePathwayStringA, direction)])[,.N,list(KoReferencePathwayStringA)][N>1]


#+END_SRC

#+NAME: DONE_make_figure
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)
  library(ggplot2)
  library(ggthemes)
  library(ggrepel)
  library(scales)
  library(rlang)
  library(assertthat)
  library(dplyr)
  library(magrittr)
  library(stringr)
  library(grid) 
  library(gtable)
  library(gridExtra)
  library(ggpubr)
  library(extrafont) 
  library(patchwork)
  loadfonts(quiet=T)

# session info
  sessionInfo()

# plot function
  do_maplot <- function(tt, fdr_threshold = 0.05, num_top_genes = 40, label_col = "symbol") {

    assert_that(is_string(label_col))
    tt <- tt %>% select(all_of(label_col), gene, logFC, z.std, AveExpr, adj.P.Val, de.status)                       
    names(tt)[[1]] <- "Gene_Label"
    y_limit <- max(abs(tt$logFC)) * 1.0 #highest logFC by abs value
    top_genes <- rbind( head(tt[!is.na(Gene_Label)][logFC<0][order(adj.P.Val)], num_top_genes), 
                       head(tt[!is.na(Gene_Label)][logFC>0][order(adj.P.Val)], num_top_genes))  %>%
        {
            bind_rows(head(., num_top_genes/2),
                      tail(., num_top_genes/2))
        } %>%
        distinct %>%
        mutate(
            nudge_y = sign(logFC) * median(abs(logFC)) * 0.2,
            nudge_x = AveExpr %>% subtract(mean(.)) %>% multiply_by(0.2)
        )
    top_up_genes <- top_genes %>% filter(logFC > 0)
    top_down_genes <- top_genes %>% filter(logFC < 0)
    all_genes <- tt %>%
        select(-Gene_Label) %>%
        arrange(AveExpr, abs(logFC))
    ggplot(all_genes) +
        aes(x = AveExpr, y = logFC) + 
        geom_point(pch=19, size=1, alpha=0.4, aes(col=de.status)) +
        scale_color_manual(values=c("#2cace2", "#d80f8c", "#999999")) +
        geom_density2d(show.legend = FALSE, alpha = 0.4, colour = "black") + #the "density map" aka the squiggles
        ##geom_smooth(show.legend = FALSE, colour = "black", se = FALSE) + #se=FALSE removes the confidence interval
        scale_size(
            name = "FDR (-log10)",
            limits = c(0, 10), range = c(0, 0.5)) +
        coord_cartesian(ylim = c(-1,1) * y_limit) +
        theme_bw() +
        theme(legend.position = "none")

  }

# de results
  #de <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")$livpmDE  
  de <- readRDS("/sc/arion/projects/psychgen2/lbp/data/RAW/rna/bulk/fromSema4/CompiledData/lbp_allBatches_RAPiD_Covs-featureCounts-vobjDream-Resids-LivPmDE_FINALModel_onlyBRAIN_518Samples_Excluding-Outliers-MislabeledSamples-BadSamples_19JUL2021.RDS")$livpmDE
  de[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  map <- fread("/sc/arion/projects/psychgen/lbp/files/gene_ids_ensembl2symbol_fromHUGO_10JUN2020.tsv")[,.(symbol=`Approved symbol`, gene=`Ensembl gene ID`)]
  de <- merge(de, map, by="gene", all.x=TRUE)
  de[,DEG2:=as.logical(ifelse(DEG=="DEG", "TRUE", "FALSE"))]
  de[,POSLFC:=as.logical(ifelse(LFC=="POSLFC", "TRUE", "FALSE"))]
  de[,de.status := "Not DE"]
  de[DEG=="DEG" & LFC=="POSLFC", de.status:="Postmortem"]
  de[DEG=="DEG" & LFC=="NEGLFC", de.status:="Living"]
  de[,de.status:=factor(de.status,levels=c("Postmortem", "Living", "Not DE"))]
  table(de$de.status)
  ##
  ##  Living     Not DE Postmortem 
  ##    9198       4449       7988 

# kegg results 
  kegg <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_keggResults_FORFIGURE.RDS")
  pdat <- kegg[[1]]

# reproducibility results

  ## wave1/wave2 results
  mywav <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_wave1vswave2de.RDS")
  mywv2 <- mywav[,.(gene, comparison="Discovery vs. Replication", logFC1=logFC.wave1, logFC2=logFC.wave2)]
  wvcor <- round(cor.test(mywv2$logFC1, mywv2$logFC2, method="spearman")$estimate, 2)

  ## pd results
  mypdx <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_pdctrl_14OCT2021.RDS")
  mypd2 <- merge(mypdx$LIVPMDE_PD[,.(gene, logFC1=logFC)], mypdx$LIVPMDE_CTRL[,.(gene, logFC2=logFC)])
  mypd2 <- mypd2[,.(gene,comparison="PD vs. Non-PD", logFC1, logFC2)] 
  pdcor <- round(cor.test(mypd2$logFC1, mypd2$logFC2, method="spearman")$estimate, 2)

  ## pmi results
  mypmi <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_diffpmi_02OCT2021.RDS")
  mypm2 <- merge(mypmi$har_livpm_lopmi[,.(gene, logFC1=logFC)], mypmi$har_livpm_hipmi[,.(gene, logFC2=logFC)])
  mypm2 <- mypm2[,.(gene,comparison="Low PMI vs. High PMI", logFC1, logFC2)]
  pmcor <- round(cor.test(mypm2$logFC1, mypm2$logFC2, method="spearman")$estimate, 2)
  
  ## pm bank results 
  mybnk <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_bank_14OCT2021.RDS")
  mybk2 <- merge(mybnk$LIVPMDE_HAR[,.(gene, logFC1=logFC)], mybnk$LIVPMDE_COL[,.(gene, logFC2=logFC)])
  mybk2 <- mybk2[,.(gene,comparison="PM1 vs. PM2", logFC1, logFC2)] 
  bkcor <- round(cor.test(mybk2$logFC1, mybk2$logFC2, method="spearman")$estimate, 2)

  ## rho text helper
  helper <- rbind( data.table(logFC1=-3, logFC2=3, comparison="Discovery vs. Replication", value=as.character(wvcor)),
                  data.table(logFC1=-3, logFC2=3, comparison="PD vs. Non-PD", value=as.character(pdcor)),
                  data.table(logFC1=-3, logFC2=3, comparison="Low PMI vs. High PMI", value=as.character(pmcor)),
                  data.table(logFC1=-3, logFC2=3, comparison="PM1 vs. PM2", value=as.character(bkcor)) )

# ma plot
  piedata <- data.table(group=c("Postmortem", "Living", "Not DE"), slices = c(7988, 9198, 4449))
  piedata[,prop:=100*(slices/sum(slices))]
  piedata[,group:=factor(group,levels=c("Postmortem", "Living", "Not DE"))]
  colordata <- rev(c("#2cace2", "#999999", "#d80f8c"))
  helperdata <- data.table(de.status=rev(c("PM DEG", "Not DEG", "LIV DEG")), ypos=c(2.3, 3, 3.7))
  helperdata[,de.status:=factor(de.status,levels=c("PM DEG", "LIV DEG", "Not DEG"))]
  mypie <- ggplot(piedata, aes(x="", y=prop, fill=group)) +
          geom_bar(stat="identity", width=1, color="white", alpha=1) +
          coord_polar("y", start=0) +
          theme_void() + 
          scale_fill_manual(values=c("#2cace2", "#d80f8c", "#999999")) +
          geom_text(aes(x=1.1, label = slices), position = position_stack(vjust = 0.5), size=2.8, col="white") +
          theme(legend.position="none", text=element_text(family="Arial", face = "bold") ) 
  myma <- do_maplot(de,num_top_genes=20) + xlab("Average Normalized Expression") + coord_fixed(ratio = 2/1)
  myma <- myma + geom_text(data=helperdata, aes(x=17, y=ypos, label=de.status), col=colordata, size = 5.5, hjust = 1, lineheight=5, fontface='bold')
  myma <- myma + annotation_custom( ggplotGrob(mypie), xmin = 8, xmax = 16, ymin = -4, ymax = -1)
  myma <- myma + theme( panel.border = element_blank(), 
                       axis.text=element_text(size=12), 
                       axis.title=element_text(size=16), 
                       text=element_text(family="Arial") )

# kegg plot
  kgcolordata <- rev(c("#2cace2", "#d80f8c"))
  kghelperdata <- data.table(de.status=rev(c("Gene sets enriched for PM DEG", "Gene sets enriched for LIV DEG")), ypos=c( (15*0.83) , 15*0.65 ))
  kghelperdata[,de.status:=factor(de.status,levels=c("Gene sets enriched for PM DEG", "Gene sets enriched for LIV DEG"))]
  kg <- ggplot(pdat, aes(parent, or, col=de)) + 
         geom_point(alpha=0.8, aes(shape=isSig, size=-log10(padj))) + 
         guides(col = FALSE, size = FALSE, shape = guide_legend(override.aes = list(shape=c(17,16), size = 3, legend.title = 1))) +
         scale_shape_discrete(name = "", labels = c("Adjusted p-value < 0.05", "Adjusted p-value > 0.05")) +
         xlab("") + ylab("Odds Ratio") +
         scale_x_discrete(labels = c(
                              "Protein families: genetic information processing" = 
                                  "Protein families:\ngenetic information processing", 
                              "Protein families: signaling and cellular processes" = 
                                  "Protein families:\nsignaling and cellular processes")) +      
         scale_color_manual(values=c("#d80f8c", "#2cace2")) +
         coord_cartesian(ylim=c(0,15)) + 
         geom_text(data=kghelperdata, aes(x=12, y=ypos, label=de.status), col=kgcolordata, size = 5.5, vjust=1.2) +
         theme_bw() +
         theme(panel.grid.major = element_blank(), 
               panel.grid.minor = element_blank(), 
               legend.title = element_text(size = 10), 
               legend.text = element_text(size = 16), 
               axis.title.x = element_text(size = 16), 
               axis.title.y = element_text(size = 16), 
               axis.text.x = element_text(angle = 90, hjust=1, vjust = 0.2, size=rel(1.3), colour="black"), 
               axis.text.y = element_text(hjust=1, size=12, colour="black"), 
               legend.position=c(0.83,0.70), 
               legend.background=element_blank(), 
               text=element_text(family="Arial")  ) 

# reproducibility plot
  pdat3 <- rbind(mywv2, mypd2,mybk2, mypm2)
  p2 <- ggscatter(pdat3, x = "logFC1", y = "logFC2", shape=21,
            add = "reg.line",
            conf.int = TRUE,  facet.by = "comparison",
            color = "black") +
       geom_text(data = helper, mapping = aes(x = logFC1, y = logFC2, label=paste("rho ==", value)), parse=T, size=5, hjust=0.1) + 
       theme(  axis.title.x = element_text(size = 16), 
               axis.title.y = element_text(size = 16),
               strip.background =element_rect(fill="black"), 
               strip.text = element_text(colour = 'white', face="bold", size=10),
               text=element_text(family="Arial")  )

# combine it all 
  layout <- c(
      area(1, 1, 2, 2),
      area(1, 3, 2, 4),
      area(3, 1, 3, 4)
  )
  final <- myma + p2 + kg + plot_layout(design = layout)
  ggsave(filename = "~/www/figures/lbp/lel2021_PRODUCTION/FORSUBMISSION/FIGURE2ZZZ.tiff", plot = final, width = 10, height = 8, device='tiff', dpi=400)
  

#+END_SRC


* FOR SUBMISSION - f3 - "the lbp coex signature"

#+NAME: DONE_MAKE_CEN_FOR_LIV_NONPD
#+BEGIN_SRC R

# setup 
  library(data.table)

# read in raw cen data
  #xnames <- load("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/raw_cen_data1.Rdata")
  #lnames <- load("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/raw_cen_data2.Rdata") 
  xnames <- load("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/raw_cen_data1_livnonpd.Rdata")
  lnames <- load("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/raw_cen_data2_livnonpd.Rdata") 
  mycen <- data.table( gene=colnames(datExpr), module=moduleColors ) ##?is this right
  xname2 <- load("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/raw_cen_data1b_livnonpd.Rdata")
  lnames <- load("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/raw_cen_data2_livnonpd.Rdata") 
  mycn2 <- data.table( gene=colnames(datExpr), module=moduleColors ) ##?is this right
  #mycen[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1L)]

# save cen
  ##saveRDS(mycen, file="/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen.RDS") 
  saveRDS(mycen, file="/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_livnonpd.RDS") 
  saveRDS(mycn2, file="/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_livnonpd_power6.RDS") 

#+END_SRC

#+NAME: DONE_differential_correlation_barplot
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)
  library(ggplot2)
  library(ggthemes)
  setwd("/sc/arion/projects/psychgen/lbp/scratch/lel2021_livpm_corrMatrixDifferences/in")

# read in lbp data
  lbp <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")

# list liv and pm degs
  lvDeg <- lbp$livpmDE[DEG=="DEG" & LFC=="NEGLFC"]$gene
  pmDeg <- lbp$livpmDE[DEG=="DEG" & LFC=="POSLFC"]$gene
  noDeg <- lbp$livpmDE[DEG=="NOTDEG"]$gene

# list liv and pm samples
  lvSam <- lbp$covariates[mymet_postmortem==0]$SAMPLE_ISMMS
  pmSam <- lbp$covariates[mymet_postmortem==1]$SAMPLE_ISMMS
  length(lvSam) #[1] 275
  length(pmSam) #[1] 243

# compare correlation matrices from liv and pm residuals
  lvCmx <- cor(t(lbp$residuals[,lvSam]))
  saveRDS(lvCmx, file="../LIV_corrMtx.RDS") 
  pmCmx <- cor(t(lbp$residuals[,pmSam]))
  saveRDS(pmCmx, file="../PM_corrMtx.RDS") 
  identical(colnames(lvCmx), colnames(pmCmx)) #[1] TRUE
  dfCmx <- pmCmx - lvCmx
  saveRDS(dfCmx, file="../PM_minus_LIV_corrDiff.RDS") 
  ##lvCmx <- readRDS("../LIV_corrMtx.RDS")  
  ##pmCmx <- readRDS("../PM_corrMtx.RDS") 
  ##dfCmx <- readRDS("../PM_minus_LIV_corrDiff.RDS") 

# determine if the LBP DEGs influence the differential correlation matrix structure

  ## formatting: make the lower half of the differential correlation matrix NA
  lvCmx <- readRDS("../LIV_corrMtx.RDS")
  pmCmx <- readRDS("../PM_corrMtx.RDS")
  dfCmx <- readRDS("../PM_minus_LIV_corrDiff.RDS")
  dfCmx[lower.tri(dfCmx)] <- NA
  dim(dfCmx) #[1] 21635 21635
  sum(is.na(dfCmx)) #[1] 234025795 ... number of cells made NA by lower.tri
    ### some sanity checks to see what lower.tri does with the diagnonal: 
    ### 21635*21635 = 468073225 ... number of cells in matrix
    ### 234025795*2 = 468051590 ... if lower.tri made half of matrix NA, this is number of cells in matrix (so this isnt what lower.tri does)
    ### 468073225 - 468051590 = 21635
    ###  ... this means that lower.tri does NOT include the diagonal 

  ## melt the differential correlation matrix into a data frame (creates very big R object)
  dec <- as.data.table(melt(dfCmx))
  nrow(dec[is.na(value)]) #[1] 234025795 ... sanity check
  dec <- dec[!is.na(value)]
  nrow(dec) #[1] 234047430 ... 234047430 - 234025795 = 21635 (because lower.tri does not include diagonal)
  colnames(dec) <- c("gene1", "gene2", "DIFF")
  dec <- dec[gene1!=gene2] # remove diagonal
  nrow(dec) #[1] 234025795 ... good, logic checks out (we expect half the matrix minus the diagonal to be here still (468073225 - 21635)/2 = 234,025,795)

  ## remove big stuff from R environment we wont use anymore (memory issues could arise otherwise)
  rm(list=c("lvCmx", "pmCmx", "dfCmx"))

  ## order data frame by absolute values of correlations (needed for next step)
  dec <- dec[order(abs(DIFF))]

  ## bin absolute values of the correlations into deciles
  dec[,DIFFDECILE := floor(1 + 10 * (.I-1) / .N)]

  ## count number of LBP DEGs in each gene-gene pair
  dec[,NDEG:=0]
  dec[gene1 %in% c(lvDeg,pmDeg) & gene2 %in% c(lvDeg,pmDeg), NDEG:=2]
  dec[gene1 %in% c(lvDeg,pmDeg) & !gene2 %in% c(lvDeg,pmDeg), NDEG:=1]
  dec[!gene1 %in% c(lvDeg,pmDeg) & gene2 %in% c(lvDeg,pmDeg), NDEG:=1]
  dec[,ABSDIFF:=abs(DIFF)]
  dec[,DIFFDECILE:=factor(DIFFDECILE, ordered=T, levels=1:10)]
  dec[,NDEG:=factor(NDEG, ordered=T, levels=c(0,1,2))]
  ctest <- cor.test(dec$DIFFDECILE, dec$NDEG, method="spearman")


# plot
  plotdata <- dec[,.N,list(DIFFDECILE, NDEG)]
  plotdata2 <- dec[,.N,list(DIFFDECILE)][,.(DIFFDECILE, DENOM=N)]
  plotdata <- merge(plotdata, plotdata2)
  plotdata[,PCT:=N/DENOM]
  plotdata[,DIFFDECILEORD:=ordered(DIFFDECILE)]
  p1 <- ggplot(plotdata[NDEG==2], aes(as.factor(DIFFDECILE), PCT)) + 
         geom_col() + 
         theme_base() + 
         coord_cartesian(ylim=c(0.6, 0.7)) + 
         ylab("Percent DEG Pairs") + xlab("Differential Coexpression Decile")
  p2 <- ggplot(plotdata, aes(as.factor(DIFFDECILE), PCT, fill=as.factor(NDEG))) + 
         geom_col() + 
         theme_base() + 
         ##coord_cartesian(ylim=c(0.6, 0.7)) + 
         ylab("Percent DEG Pairs") + xlab("Differential Coexpression Decile")
  pdf("~/www/figures/lbp/lel2021_PRODUCTION/DECILES.pdf")
      show(p1)
  dev.off()













#-gabes way-------------------------------------------------------------

lvCmx <- readRDS("../LIV_corrMtx.RDS")
pmCmx <- readRDS("../PM_corrMtx.RDS")
nlvCmx <- 275
npmCmx <- 243
lvCmxSe <- sqrt(1 - lvCmx^2) / sqrt(nlvCmx-2)
pmCmxSe <- sqrt(1 - pmCmx^2) / sqrt(npmCmx-2)
tsCmx <-  (pmCmx - lvCmx) / sqrt(pmCmxSe^2 + lvCmxSe^2)
tsCmx[lower.tri(tsCmx)] <- NA
dec <- as.data.table(melt(tsCmx))
dec <- dec[!is.na(value) & !is.nan(value)]
colnames(dec) <- c("gene1", "gene2", "TSTAT")
dec <- dec[gene1!=gene2] # remove diagonal
nrow(dec) #[1] 234025795
## remove big stuff from R environment we wont use anymore (memory issues could arise otherwise)
rm(list=c("lvCmx", "pmCmx", "tsCmx", "lvCmxSe", "pmCmxSe"))
dec[,ABSTSTAT:=abs(TSTAT)]
dec[,NDEG:=0]
dec[gene1 %in% c(lvDeg,pmDeg) & gene2 %in% c(lvDeg,pmDeg), NDEG:=2]
dec[gene1 %in% c(lvDeg,pmDeg) & !gene2 %in% c(lvDeg,pmDeg), NDEG:=1]
dec[!gene1 %in% c(lvDeg,pmDeg) & gene2 %in% c(lvDeg,pmDeg), NDEG:=1]
wres01 <- wilcox.test(dec[NDEG==0]$ABSTSTAT, dec[NDEG==1]$ABSTSTAT) #W = 3.6311e+14, p-value < 2.2e-16
wres02 <- wilcox.test(dec[NDEG==0]$ABSTSTAT, dec[NDEG==2]$ABSTSTAT)
wres12 <- wilcox.test(dec[NDEG==1]$ABSTSTAT, dec[NDEG==2]$ABSTSTAT)




#+END_SRC

#+NAME: DONE_cen_conservation
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)
  library(ggplot2)
  library(ggthemes)
  library(seriation)
  library(gridExtra)
  library(grid)
  library(cowplot)
  source("/hpc/users/charna02/www/figures/lbp/lel2021_PRODUCTION/FIGURE_FUNCTIONS.r")

# read in lbp data
  lbp <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")

# coexpression data
  cenList <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_subsets.RDS")
  cenFish <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_subsets_overlap.RDS")

# add liv nonpd (power 7)
  cenList$livNonPD <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_livnonpd.RDS") 
  newCenFish <- c()
  for (i in c("harvardControl", "columbiaControl", "harvardPD", "columbiaPD", "livPD")){
      print(i)
      add <- fishModSim(cen.list=cenList, cen1=i, cen2="livNonPD")
      newCenFish <- rbind(newCenFish, add)
  }
  newCenFish[cen1!="livPD",color:="dead-liv"]
  newCenFish[cen1=="livPD",color:="liv-liv"]
  newCenFish[,comp:=paste(cen1,cen2,sep="-")]
  newCenFish[,fisher.p.adjust:=p.adjust(fisher.p,"fdr")]
  cenFish <- rbind(cenFish,newCenFish)
  saveRDS(cenFish, file="/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_subsets_overlap_withLivNonpd.RDS")

#+END_SRC
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)
  library(ggplot2)
  library(ggthemes)
  library(seriation)
  library(gridExtra)
  library(grid)
  library(cowplot)
  source("/hpc/users/charna02/www/figures/lbp/lel2021_PRODUCTION/FIGURE_FUNCTIONS.r")

# read in lbp data
  lbp <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")

# coexpression data
  cenList <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_subsets.RDS")
  cenList$livNonPD <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_livnonpd.RDS") 
  cenFish <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_subsets_overlap_withLivNonpd.RDS")
  cenCombos <- as.data.table(t(combn(names(cenList), 2) ))
  cenListSize <- lapply(cenList, function(x) x[,.N,module][order(N)])
  for (i in 1:length(cenListSize)) cenListSize[[i]][,SIZE := floor( 1 + 2 * (.I-1) / .N)]

# kegg data 
  keg <- fread("/sc/arion/projects/psychgen/lbp/resources/kegg/hsa00001_noheader_PARSED_MAPPED2ENSEMBL.tsv")
  keg[,awcid:=paste(TopLevelString,SuperPathwayCode,KoReferencePathwayCode,sep="|")]
  keg.nogene <- unique(keg[,.(awcid, TopLevelString,SuperPathwayStringA,SuperPathwayStringB,KoReferencePathwayStringA)])
  kgLst <- split(unique(keg[,.(awcid,gene)]), by="awcid")
  kgLst <- lapply(kgLst, function(x) x$gene)

# best matches
  myBest <- c()
  for (i in 1:nrow(cenCombos)){
      print(i)
      c1 <- cenCombos[i]$V1
      c2 <- cenCombos[i]$V2
      mod <- list( unique(cenList[[c1]]$module), unique(cenList[[c2]]$module) )
      names(mod) <- c(c1, c2)
      for (j in c(c1, c2)){
          if (j==c1) other <- c2
          if (j==c2) other <- c1
          for (k in mod[[j]]){
              if (j==c1){
                  cur <- cenFish[cen1==j & cen2==other & mod1==k][order(fisher.p)][1]
                  idx.cen <- j
                  com.cen <- other
                  idx.mod <- k
                  com.mod <- cur$mod2
                  idx.mod.size <- cur$mod1.size
                  com.mod.size <- cur$mod2.size
              } else {
                  cur <- cenFish[cen2==j & cen1==other & mod2==k][order(fisher.p)][1]
                  idx.cen <- j
                  com.cen <- other
                  idx.mod <- k
                  com.mod <- cur$mod1
                  idx.mod.size <- cur$mod2.size
                  com.mod.size <- cur$mod1.size
              }
              add <- data.table( indexCEN=idx.cen, compareCEN=com.cen,
                                indexMod=idx.mod, compareMod=com.mod,
                                indexModSize=idx.mod.size, compareModSize=com.mod.size,
                                fisher.estimate=cur$fisher.estimate, fisher.p=cur$fisher.p, fisher.p.adjust=cur$fisher.p.adjust )
              myBest <- rbind(myBest, add)                       
          }            
      }
  }
  myBest[grep("har", indexCEN),indexBank:="HVD"]
  myBest[grep("col", indexCEN),indexBank:="CBA"]
  myBest[grep("liv", indexCEN),indexBank:="LBP"]
  myBest[grep("har", compareCEN),compareBank:="HVD"]
  myBest[grep("col", compareCEN),compareBank:="CBA"]
  myBest[grep("liv", compareCEN),compareBank:="LBP"]
  myBest[grep("Control", indexCEN),indexPhe:="CON"]
  myBest[grep("Control", compareCEN),comparePhe:="CON"]
  myBest[grep("PD", indexCEN),indexPhe:="PD"]
  myBest[grep("PD", compareCEN),comparePhe:="PD"]
  myBest[grep("NonPD", indexCEN),indexPhe:="NONPD"]
  myBest[grep("NonPD", compareCEN),comparePhe:="NONPD"]
  myBest[ (indexBank=="HVD" & compareBank=="LBP"), bankPair:="PM-LIV"]
  myBest[ (indexBank=="LBP" & compareBank=="HVD"), bankPair:="LIV-PM"]
  myBest[ (indexBank=="CBA" & compareBank=="LBP"), bankPair:="PM-LIV"]
  myBest[ (indexBank=="LBP" & compareBank=="CBA"), bankPair:="LIV-PM"]
  myBest[ (indexBank=="HVD" & compareBank=="CBA") | (indexBank=="CBA" & compareBank=="HVD"), bankPair:="PM-PM"]
  myBest[ (indexBank=="HVD" & compareBank=="HVD") | (indexBank=="CBA" & compareBank=="CBA"), bankPair:="PM-PM"]
  myBest[ (indexBank=="LBP" & compareBank=="LBP"), bankPair:="LIV-LIV"]
  myBest[ (indexPhe=="CON" & comparePhe=="CON"), phePair:="CON-CON"]
  myBest[ (indexPhe=="PD" & comparePhe=="PD"), phePair:="PD-PD"]
  myBest[ (indexPhe=="PD" & comparePhe=="CON"), phePair:="PD-CON"]
  myBest[ (indexPhe=="CON" & comparePhe=="PD"), phePair:="CON-PD"]
  myBest[ (indexPhe=="PD" & comparePhe=="NONPD"), phePair:="PD-NONPD"]
  myBest[ (indexPhe=="NONPD" & comparePhe=="PD"), phePair:="NONPD-PD"]
  myBest[ (indexPhe=="CON" & comparePhe=="NONPD"), phePair:="CON-NONPD"]
  myBest[ (indexPhe=="NONPD" & comparePhe=="CON"), phePair:="NONPD-CON"]

# identify conserved modules
  allall <- c("livPD","livNonPD","columbiaPD","harvardPD","columbiaControl", "harvardControl")
  allal2 <- c("livPD","columbiaPD","harvardPD","columbiaControl", "harvardControl")
  nogrey <- myBest[indexMod!="grey" & compareMod!="grey"]
  x1 <- findConsensusModules( stats = nogrey, nets = allall, refnet =  allall[1], cenlist = cenList)
  conmod <- x1$meta
  conmodgenes <- findConsensusModuleGenes(conmod, cenList)

# enrichment of conserved modules for lbp deg
  lvDeg <- lbp$livpmDE[DEG=="DEG" & LFC=="NEGLFC"]$gene  
  pmDeg <- lbp$livpmDE[DEG=="DEG" & LFC=="POSLFC"]$gene
  bb <- lbp$livpmDE[,.(gene, module=0, lv=0, pm=0)]
  bb[gene %in% lvDeg, lv:=1]
  bb[gene %in% pmDeg, pm:=1]
  degEnrich <- c()
  for (i in 1:nrow(conmod)){
      for (j in 1:ncol(conmod)){
          cur <- copy(bb)
          net <- colnames(conmod)[j]
          mod <- conmod[[net]][i]
          mdg <- cenList[[net]][module==mod]$gene
          cur[gene %in% mdg, module:=1]
          fish1 <- fisher.test(table(cur$module, cur$lv), alternative="greater")
          fish2 <- fisher.test(table(cur$module, cur$pm), alternative="greater")
          add <- data.table( "conservedMod"=i, "indexCEN"=net, "indexMod"=mod, 
                            "indexPmOverlap"=length(intersect(mdg, pmDeg)), 
                            "indexLvOverlap"=length(intersect(mdg, lvDeg)), 
                            "indexLvEstimate"=fish1$estimate, "indexLvPval"=fish1$p.value,
                            "indexPmEstimate"=fish2$estimate, "indexPmPval"=fish2$p.value )
          cr2 <- cur[,.(gene, deg=module)]
          cr2[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1L)]
          x <- runKegg(cr2, mod, kgLst)
          x <- merge(x, keg.nogene) 
          x <- x[TopLevelString!="Human"]
          x[,padj:=p.adjust(pval, "fdr")]
          nsig <- nrow(x[padj<0.05])
          if (nsig > 0){
              mostsig <- x[order(padj)][1]
              mostsig[is.na(SuperPathwayStringB),parent:=SuperPathwayStringA]
              mostsig[!is.na(SuperPathwayStringB),parent:=paste(SuperPathwayStringA, SuperPathwayStringB, sep=": ")]
              kgAdd <- mostsig[,.(kegTerm=KoReferencePathwayStringA, kegParent=parent, kegOR=or, kegPADJ=padj)]
          } else {
              kgAdd <- mostsig[,.(kegTerm=NA, kegParent=NA, kegOR=NA, kegPADJ=NA)]
          }
          add <- cbind(add, kgAdd)
          degEnrich <- rbind(degEnrich, add)
      }
  }
  degEnrich[,indexLvPvalAdj:=p.adjust(indexLvPval, "fdr")]
  degEnrich[,indexPmPvalAdj:=p.adjust(indexPmPval, "fdr")]
  degEnrich[,conservedMod:=paste0("module",conservedMod)]
  degEnrich[,livSig:=FALSE]
  degEnrich[,pmSig:=FALSE]
  degEnrich[indexLvPvalAdj<0.05,livSig:=TRUE]
  degEnrich[indexPmPvalAdj<0.05,pmSig:=TRUE]

# conserved module deg enrichment figure
  lvMod <- degEnrich[livSig==TRUE,.N,conservedMod][N>=3]$conservedMod
  pmMod <- degEnrich[pmSig==TRUE,.N,conservedMod][N>=3]$conservedMod
  noMod <- unique(degEnrich$conservedMod)[!unique(degEnrich$conservedMod) %in% c(lvMod,pmMod)]
  lvVal <- degEnrich[conservedMod %in% lvMod,list(or=max(indexLvEstimate)),by=list(conservedMod)]
  pmVal <- degEnrich[conservedMod %in% pmMod,list(or=max(indexPmEstimate)),by=list(conservedMod)]
  noVal <- degEnrich[conservedMod %in% noMod,list(or=max(indexPmEstimate)),by=list(conservedMod)]
  pmVal[,or:=-or]
  noVal[,or:=0]
  myOrd <- rbind(lvVal, pmVal, noVal)[order(or, decreasing=T)]$conservedMod
  degEnrich[,conservedMod:=factor(conservedMod, levels=myOrd)]
  degEnrich <- degEnrich[order(conservedMod)]
  degEnrich <- merge(degEnrich, data.table(conservedMod=myOrd, module=1:length(myOrd))) 
  degEnrich <- degEnrich[order(module)]
  xy1 <- degEnrich[(indexPmPvalAdj<0.05 | indexLvPvalAdj<0.05) & indexPmPvalAdj<indexLvPvalAdj, .(module, indexCEN, or=indexPmEstimate, p=indexPmPvalAdj, group="pm")]
  xy2 <- degEnrich[(indexPmPvalAdj<0.05 | indexLvPvalAdj<0.05) & indexLvPvalAdj<indexPmPvalAdj, .(module, indexCEN, or=indexLvEstimate, p=indexLvPvalAdj, group="lv")]
  xy3 <- degEnrich[(indexPmPvalAdj>0.05 & indexLvPvalAdj>0.05) , .(module, indexCEN, or=indexLvEstimate, p=indexLvPvalAdj, group="insig")]
  xy <- rbind(xy1, xy2, xy3) 
  xy[,myfacet:="LBP signature"]
  colOrd <- c("columbiaControl", "columbiaPD", "harvardControl", "harvardPD", "livNonPD", "livPD")
  xy[,indexCEN:=factor(indexCEN, colOrd)]
  xz <- degEnrich[, .(module, indexCEN, or=kegOR, p=kegPADJ, group=kegTerm, myfacet="KEGG")]
  colOrd <- c("columbiaControl", "columbiaPD", "harvardControl", "harvardPD", "livNonPD", "livPD")
  xz[,indexCEN:=factor(indexCEN, colOrd)]
  keepme <- xy[group!="insig",.N,module]$module
  xy <- xy[module %in% keepme]
  xz <- xz[module %in% keepme]
  pdat <- rbind(xy, xz)
  pdat[,module:=paste0("CM", module)]
  pdat[,module:=factor(module, levels=c("CM3","CM2","CM1"))]
  pdat[,myfacet:=factor(myfacet, levels=c("LBP signature", "KEGG"))]
  pdat[,myalpha:=TRUE]
  pdat[group=="insig", myalpha:=FALSE]
  pdat[group=="insig", group:="lv"]
  ggplot(pdat, aes(or, module, group=indexCEN, alpha=myalpha, fill=group)) + 
      scale_fill_manual(values=c("#2cace2", "antiquewhite4", "cadetblue4", "coral4")) +
      geom_bar(col="black",stat="identity", position="dodge") + 
      facet_grid(~myfacet, scales="free_x") +
      theme_base()





#+END_SRC

#+NAME: DONE_make_figure_data
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)
  library(ggplot2)
  library(ggthemes)
  library(ggrepel)
  library(scales)
  library(rlang)
  library(assertthat)
  library(dplyr)
  library(magrittr)
  library(stringr)
  library(grid)
  library(gridExtra)
  library(egg)
  library(cowplot)
  library(patchwork)
  library(seriation)
  source("/sc/arion/projects/psychgen/lbp/scripts/lel2021_FigureFunctions.r") 
  setwd("/sc/arion/projects/psychgen/lbp/scratch/lel2021_livpm_corrMatrixDifferences/in")

# histogram
  ##lbp <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")
  lbp <- readRDS("/sc/arion/projects/psychgen2/lbp/data/RAW/rna/bulk/fromSema4/CompiledData/lbp_allBatches_RAPiD_Covs-featureCounts-vobjDream-Resids-LivPmDE_FINALModel_onlyBRAIN_518Samples_Excluding-Outliers-MislabeledSamples-BadSamples_19JUL2021.RDS")
  lvDeg <- lbp$livpmDE[DEG=="DEG" & LFC=="NEGLFC"]$gene
  pmDeg <- lbp$livpmDE[DEG=="DEG" & LFC=="POSLFC"]$gene
  noDeg <- lbp$livpmDE[DEG=="NOTDEG"]$gene
  length(lvDeg) #[1] 9198
  length(pmDeg) #[1] 7988
  length(noDeg) #[1] 4449
  lvSam <- lbp$covariates[mymet_postmortem==0]$SAMPLE_ISMMS
  pmSam <- lbp$covariates[mymet_postmortem==1]$SAMPLE_ISMMS
  length(lvSam) #[1] 275
  length(pmSam) #[1] 243
  lvCmx <- cor(t(lbp$residuals[,lvSam]))
  pmCmx <- cor(t(lbp$residuals[,pmSam]))
  identical(colnames(lvCmx), colnames(pmCmx)) #[1] TRUE ... good, just a sanity check before comparing these to each other
  dfCmx <- pmCmx - lvCmx
  dim(dfCmx) #[1] 21635 21635 ... 21635*21635 = 468073225 ... just keeping track of what we are dealing with here
  sum(is.na(dfCmx)) #[1] 0 ... good, sanity check there are no NAs for any reason in this matrix
  ##lvCmx <- readRDS("../LIV_corrMtx.RDS")
  ##pmCmx <- readRDS("../PM_corrMtx.RDS")
  ##dfCmx <- readRDS("../PM_minus_LIV_corrDiff.RDS")
  lpmean <- mean(abs(unlist(dfCmx))) #[1] 0.1402479 using all of the living-pm data
  rm(lvCmx)
  rm(pmCmx)
  rm(dfCmx)
  perms <- fread("/sc/arion/projects/psychgen/lbp/scratch/lel2021_livpm_corrMatrixDifferences/permutations/10000perms_AllRand/combined.tsv", header=T)
  perms$diffMatrix <- as.factor(perms$diffMatrix)
  perms$greaterThanLPmean <- NA
  for (i in 1:nrow(perms)) {
      if (perms$meanCorrDiff[i]>lpmean) {
          perms$greaterThanLPmean[i] <- TRUE
      }
      else {
          perms$greaterThanLPmean[i] <- FALSE
      }
  }
  vertical_segment_data <- data.frame( #for geom_segment, tells it where to put the line segments
      x = c(0.099625, 0.137625), #(0.099 - 0.09725) + (0.14 - 0.137) = 0.00475/2 = 0.002375 on each side of the |---- emp p-val ----|
      xend = c(0.099625, 0.137625), 
      y = c(580, 580),
      yend = c(620, 620)
  )
  segment_data <- data.frame( #for geom_segment, tells it where to put the line segments, i.e., on each side of the geom_text p-value
      ##x = c(0.099625, 0.131625),
      ##xend = c(0.105625, 0.137625), 
      x = c(0.099625, 0.12725),
      xend = c(0.11, 0.137625), 
      y = c(600, 600),
      yend = c(600, 600)
  )
  perms[, name:= "Gene-Gene Correlation Difference Matrix Means"]

# barplots
  cenList <- readRDS("/sc/arion/projects/psychgen/lbp/files/files_from_psychgen2/lbp_allBatches_wgcna/lbp_allBatches_RAPiD_FinalModel-NoOutliers_wgcna_geneInfoFiles_separatePDnonPDnetworks_livHarvColumbia_31AUG2021.RDS")
  cenFish <- readRDS("/sc/arion/projects/psychgen/lbp/files/files_from_psychgen2/lbp_allBatches_wgcna/lbp_allBatches_RAPiD_FinalModel-NoOutliers_wgcna_separatePDnonPDnetworks_livHarvColumbia_pairwiseModuleComparisons_31AUG2021.RDS")
  xnames <- load("/sc/arion/projects/psychgen/lbp/files/files_from_psychgen2/lbp_allBatches_wgcna/lbp_allBatches_RAPiD_FinalModel-NoOutliers_wgcna_networkConstruction-stepByStep_Power7_PearsonCorr_NoMergedModules_livControlOnly_50Samples_01OCT2021.RData")
  lnames <- load("/sc/arion/projects/psychgen/lbp/files/files_from_psychgen2/lbp_allBatches_wgcna/lbp_allBatches_RAPiD_FinalModel-NoOutliers_wgcna_datExpr_datTraits_249livControlOnly_01OCT2021.RData")
  mycen <- data.table( gene=colnames(datExpr), module=moduleColors ) ##DON'T FORGET THIS LINE
  cenList$livNonPD <- mycen #DON'T FORGET THIS LINE
  newCenFish <- c()
  for (i in c("harvardControl", "columbiaControl", "harvardPD", "columbiaPD", "livPD")){
      print(i)
      add <- fishModSim(cen.list=cenList, cen1=i, cen2="livNonPD")
      newCenFish <- rbind(newCenFish, add)
  }
  newCenFish[cen1!="livPD",color:="dead-liv"]
  newCenFish[cen1=="livPD",color:="liv-liv"]
  newCenFish[,comp:=paste(cen1,cen2,sep="-")]
  newCenFish[,fisher.p.adjust:=p.adjust(fisher.p,"fdr")]
  cenFish <- rbind(cenFish,newCenFish)
  saveRDS(cenFish, file="/sc/arion/projects/psychgen/scratch/lbp_allBatches_RAPiD_FinalModel_forPaper_Figure4_cen-subsets-overlap-withLivNonpd_cenFish_01NOV2021.RDS")
  ##cenFish <- readRDS("/sc/arion/projects/psychgen/scratch/lbp_allBatches_RAPiD_FinalModel_forPaper_Figure4_cen-subsets-overlap-withLivNonpd_cenFish_01NOV2021.RDS")
  cenCombos <- as.data.table(t(combn(names(cenList), 2) ))
  cenListSize <- lapply(cenList, function(x) x[,.N,module][order(N)]) ##not sure what this is for anymore
  for (i in 1:length(cenListSize)) cenListSize[[i]][,SIZE := floor( 1 + 2 * (.I-1) / .N)] ##not sure what this is for anymore
  keg <- fread("/sc/arion/projects/psychgen/lbp/resources/kegg/hsa00001_noheader_PARSED_MAPPED2ENSEMBL.tsv")
  keg[,awcid:=paste(TopLevelString,SuperPathwayCode,KoReferencePathwayCode,sep="|")]
  keg.nogene <- unique(keg[,.(awcid, TopLevelString,SuperPathwayStringA,SuperPathwayStringB,KoReferencePathwayStringA)])
  kgLst <- split(unique(keg[,.(awcid,gene)]), by="awcid")
  kgLst <- lapply(kgLst, function(x) x$gene)
  myBest <- c()
  for (i in 1:nrow(cenCombos)){
      print(i)
      c1 <- cenCombos[i]$V1
      c2 <- cenCombos[i]$V2
      mod <- list( unique(cenList[[c1]]$module), unique(cenList[[c2]]$module) )
      names(mod) <- c(c1, c2)
      for (j in c(c1, c2)){
          if (j==c1) other <- c2
          if (j==c2) other <- c1
          for (k in mod[[j]]){
              if (j==c1){
                  cur <- cenFish[cen1==j & cen2==other & mod1==k][order(fisher.p)][1] #order based on p and choose the best p aka the first one in the order
                  idx.cen <- j
                  com.cen <- other
                  idx.mod <- k
                  com.mod <- cur$mod2
                  idx.mod.size <- cur$mod1.size
                  com.mod.size <- cur$mod2.size
              } else {
                  cur <- cenFish[cen2==j & cen1==other & mod2==k][order(fisher.p)][1]
                  idx.cen <- j
                  com.cen <- other
                  idx.mod <- k
                  com.mod <- cur$mod1
                  idx.mod.size <- cur$mod2.size
                  com.mod.size <- cur$mod1.size
              }
              add <- data.table( indexCEN=idx.cen, compareCEN=com.cen,
                                indexMod=idx.mod, compareMod=com.mod,
                                indexModSize=idx.mod.size, compareModSize=com.mod.size,
                                fisher.estimate=cur$fisher.estimate, fisher.p=cur$fisher.p, fisher.p.adjust=cur$fisher.p.adjust )
              myBest <- rbind(myBest, add)                       
          }            
      }
  }
  myBest[grep("har", indexCEN),indexBank:="HVD"]
  myBest[grep("col", indexCEN),indexBank:="CBA"]
  myBest[grep("liv", indexCEN),indexBank:="LBP"]
  myBest[grep("har", compareCEN),compareBank:="HVD"]
  myBest[grep("col", compareCEN),compareBank:="CBA"]
  myBest[grep("liv", compareCEN),compareBank:="LBP"]
  myBest[grep("Control", indexCEN),indexPhe:="CON"]
  myBest[grep("Control", compareCEN),comparePhe:="CON"]
  myBest[grep("PD", indexCEN),indexPhe:="PD"]
  myBest[grep("PD", compareCEN),comparePhe:="PD"]
  myBest[grep("NonPD", indexCEN),indexPhe:="NONPD"]
  myBest[grep("NonPD", compareCEN),comparePhe:="NONPD"]
  myBest[ (indexBank=="HVD" & compareBank=="LBP"), bankPair:="PM-LIV"]
  myBest[ (indexBank=="LBP" & compareBank=="HVD"), bankPair:="LIV-PM"]
  myBest[ (indexBank=="CBA" & compareBank=="LBP"), bankPair:="PM-LIV"]
  myBest[ (indexBank=="LBP" & compareBank=="CBA"), bankPair:="LIV-PM"]
  myBest[ (indexBank=="HVD" & compareBank=="CBA") | (indexBank=="CBA" & compareBank=="HVD"), bankPair:="PM-PM"]
  myBest[ (indexBank=="HVD" & compareBank=="HVD") | (indexBank=="CBA" & compareBank=="CBA"), bankPair:="PM-PM"]
  myBest[ (indexBank=="LBP" & compareBank=="LBP"), bankPair:="LIV-LIV"]
  myBest[ (indexPhe=="CON" & comparePhe=="CON"), phePair:="CON-CON"]
  myBest[ (indexPhe=="PD" & comparePhe=="PD"), phePair:="PD-PD"]
  myBest[ (indexPhe=="PD" & comparePhe=="CON"), phePair:="PD-CON"]
  myBest[ (indexPhe=="CON" & comparePhe=="PD"), phePair:="CON-PD"]
  myBest[ (indexPhe=="PD" & comparePhe=="NONPD"), phePair:="PD-NONPD"]
  myBest[ (indexPhe=="NONPD" & comparePhe=="PD"), phePair:="NONPD-PD"]
  myBest[ (indexPhe=="CON" & comparePhe=="NONPD"), phePair:="CON-NONPD"]
  myBest[ (indexPhe=="NONPD" & comparePhe=="CON"), phePair:="NONPD-CON"]
  allall <- c("livPD","livNonPD","columbiaPD","harvardPD","columbiaControl", "harvardControl")
  ##allal2 <- c("livPD","columbiaPD","harvardPD","columbiaControl", "harvardControl")
  nogrey <- myBest[indexMod!="grey" & compareMod!="grey"]
  x1 <- findConsensusModules( stats = nogrey, nets = allall, refnet =  allall[1], cenlist = cenList)
  conmod <- x1$meta
  lvDeg <- lbp$livpmDE[DEG=="DEG" & LFC=="NEGLFC"]$gene  
  pmDeg <- lbp$livpmDE[DEG=="DEG" & LFC=="POSLFC"]$gene
  bb <- lbp$livpmDE[,.(gene, module=0, lv=0, pm=0)]
  bb[gene %in% lvDeg, lv:=1]
  bb[gene %in% pmDeg, pm:=1]
  bb[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1L)]
  degEnrich <- c()
  for (i in 1:nrow(conmod)){
      for (j in 1:ncol(conmod)){
          cur <- copy(bb)
          net <- colnames(conmod)[j]
          mod <- conmod[[net]][i]
          mdg <- cenList[[net]][module==mod]$gene
          mdg <- tstrsplit(mdg, ".", fixed=T, keep=1L)[[1]]
          cur[gene %in% mdg, module:=1]
          fish1 <- fisher.test(table(cur$module, cur$lv), alternative="greater")
          fish2 <- fisher.test(table(cur$module, cur$pm), alternative="greater")
          add <- data.table( "conservedMod"=i, "indexCEN"=net, "indexMod"=mod, 
                            "indexPmOverlap"=length(intersect(mdg, pmDeg)), 
                            "indexLvOverlap"=length(intersect(mdg, lvDeg)), 
                            "indexLvEstimate"=fish1$estimate, "indexLvPval"=fish1$p.value,
                            "indexPmEstimate"=fish2$estimate, "indexPmPval"=fish2$p.value )
          cr2 <- cur[,.(gene, deg=module)]
          x <- runKegg(cr2, mod, kgLst)
          x <- merge(x, keg.nogene) 
          x <- x[TopLevelString!="Human"]
          x[,padj:=p.adjust(pval, "fdr")]
          nsig <- nrow(x[padj<0.05])
          if (nsig > 0){
              mostsig <- x[order(padj)][1]
              mostsig[is.na(SuperPathwayStringB),parent:=SuperPathwayStringA]
              mostsig[!is.na(SuperPathwayStringB),parent:=paste(SuperPathwayStringA, SuperPathwayStringB, sep=": ")]
              kgAdd <- mostsig[,.(kegTerm=KoReferencePathwayStringA, kegParent=parent, kegOR=or, kegPADJ=padj)]
          } else {
              kgAdd <- mostsig[,.(kegTerm=NA, kegParent=NA, kegOR=NA, kegPADJ=NA)]
          }
          add <- cbind(add, kgAdd)
          degEnrich <- rbind(degEnrich, add)
      }
  }
  degEnrich[,indexLvPvalAdj:=p.adjust(indexLvPval, "fdr")]
  degEnrich[,indexPmPvalAdj:=p.adjust(indexPmPval, "fdr")]
  degEnrich[,conservedMod:=paste0("module",conservedMod)]
  degEnrich[,livSig:=FALSE]
  degEnrich[,pmSig:=FALSE]
  degEnrich[indexLvPvalAdj<0.05,livSig:=TRUE]
  degEnrich[indexPmPvalAdj<0.05,pmSig:=TRUE]
  saveRDS(degEnrich, file = "/sc/arion/projects/psychgen/scratch/lbp_allBatches_RAPiD_FinalModel_forPaper_Figure4_cen-subsets_degEnrich_01NOV2021.RDS")
  lvMod <- degEnrich[livSig==TRUE,.N,conservedMod][N>=3]$conservedMod
  pmMod <- degEnrich[pmSig==TRUE,.N,conservedMod][N>=3]$conservedMod
  noMod <- unique(degEnrich$conservedMod)[!unique(degEnrich$conservedMod) %in% c(lvMod,pmMod)]
  lvVal <- degEnrich[conservedMod %in% lvMod,list(or=max(indexLvEstimate)),by=list(conservedMod)]
  pmVal <- degEnrich[conservedMod %in% pmMod,list(or=max(indexPmEstimate)),by=list(conservedMod)] #gives warning because there is no pmVal - its ok
  noVal <- degEnrich[conservedMod %in% noMod,list(or=max(indexPmEstimate)),by=list(conservedMod)]
  pmVal[,or:=-or]
  noVal[,or:=0]
  myOrd <- rbind(lvVal, pmVal, noVal)[order(or, decreasing=T)]$conservedMod
  degEnrich[,conservedMod:=factor(conservedMod, levels=myOrd)]
  degEnrich <- degEnrich[order(conservedMod)]
  degEnrich <- merge(degEnrich, data.table(conservedMod=myOrd, module=1:length(myOrd))) 
  degEnrich <- degEnrich[order(module)]
  xy1 <- degEnrich[(indexPmPvalAdj<0.05 | indexLvPvalAdj<0.05) & indexPmPvalAdj<indexLvPvalAdj, .(module, indexCEN, or=indexPmEstimate, p=indexPmPvalAdj, group="pm")]
  xy2 <- degEnrich[(indexPmPvalAdj<0.05 | indexLvPvalAdj<0.05) & indexLvPvalAdj<indexPmPvalAdj, .(module, indexCEN, or=indexLvEstimate, p=indexLvPvalAdj, group="lv")]
  xy3 <- degEnrich[(indexPmPvalAdj>0.05 & indexLvPvalAdj>0.05) , .(module, indexCEN, or=indexLvEstimate, p=indexLvPvalAdj, group="insig")]
  xy <- rbind(xy1, xy2, xy3) 
  xy[,myfacet:="LBP signature"]
  colOrd <- c("columbiaControl", "columbiaPD", "harvardControl", "harvardPD", "livNonPD", "livPD")
  xy[,indexCEN:=factor(indexCEN, colOrd)]
  xy[,group:=factor(group, levels=c("lv","insig"))]
  xz <- degEnrich[, .(module, indexCEN, or=kegOR, p=kegPADJ, group=kegTerm, myfacet="KEGG")]
  colOrd <- c("columbiaControl", "columbiaPD", "harvardControl", "harvardPD", "livNonPD", "livPD")
  xz[,indexCEN:=factor(indexCEN, colOrd)]
  keepme <- xy[group!="insig",.N,module]$module
  xy <- xy[module %in% keepme]
  xz <- xz[module %in% keepme]
  xy$title <- "LIV DEG Enrichment"
  xz$title <- "Top KEGG Gene Set Enrichment"
  p1_labels <- c("CM1", "CM2", "CM3")

  p1 <- ggplot(xy, aes(as.factor(module), or, group=indexCEN, fill=group)) + 
         geom_bar(col="black",stat="identity", position="dodge") +
         theme_bw() +
         scale_fill_manual(name = "", labels = c("Adjusted p-value < 0.05", "Adjusted p-value > 0.05"), values = c("#d80f8c", "#fbe7f3")) +
         theme( panel.grid.major = element_blank(), 
            panel.grid.minor = element_blank(), 
            panel.background = element_blank(), 
            axis.line = element_line(colour = "black"), 
            legend.title = element_text(size = 10), 
            legend.text = element_text(size = 10), 
            #legend.position=c(.68,.25), 
            legend.position=c(.77,.8), 
            legend.background=element_blank(),
            axis.title.y = element_blank(), 
            axis.title.x = element_blank(), 
            text=element_text(size=12, family="ArialMT")) + 
       scale_y_discrete(labels = p1_labels) +
       facet_grid(. ~ title) + #to get the title of the plot in a grey box; this is a facet wrap "cheat"
       theme(strip.background =element_rect(fill="black")) + #to change the color of the grey box from grey to something else
       theme(strip.text = element_text(colour = 'white', size = 12)) #+ #to change the text inside the grey box 

  xz$group <- factor(xz$group, levels=c("Ribosome", "Oxidative phosphorylation", "Non-coding RNAs"))
  p2 <- ggplot(xz, aes(as.factor(module), or, group=indexCEN, fill=group)) + 
      geom_bar(col="black",stat="identity", position="dodge") + theme_bw() +
      theme(panel.grid.major = element_blank(), 
            panel.grid.minor = element_blank(), 
            panel.background = element_blank(), 
            axis.line = element_line(colour = "black"), 
            legend.title = element_text(size = 10), 
            legend.text = element_text(size = 10), 
            #legend.position=c(.70,.25), 
            legend.position=c(.77,.8), 
            legend.background=element_blank(),
            #axis.title.x = element_blank(), 
            text=element_text(size=12, family="ArialMT")) +
            xlab("Conserved Network Structure") +
      scale_y_discrete(breaks = NULL, labels = NULL) + #scale_fill_discrete(name = "") + 
      scale_fill_manual(name = "", values=c("#00BA38", "#F8766D", "#C77CFF")) + ###CHANGE COLORS
      facet_grid(. ~ title) + ylab("") + # + xlab("Odds Ratio")  
      theme(strip.background =element_rect(fill="black")) + #to change the color of the grey box from grey to something else
      theme(strip.text = element_text(colour = 'white', size = 12)) #+ #to change the text inside the grey box 

# boxplot 
  segment_data1 <- data.frame(
      xstart = c(1-0.025, 1-0.025),
      xend = c(1+0.025, 1+0.025), 
      ystart = c(0.107, 0.135625),
      yend = c(0.107, 0.135625)
  )
  segment_data2 <- data.frame(
      xstart = c(1),
      xend = c(1), 
      ystart = c(0.107),
      yend = c(0.135625)
  )
  my_custom_labels <- c("0.09","","","","","0.14")  
  my_custom_values <- c(0.09, 0.10, 0.11, 0.12, 0.13, 0.14)
  boxplot <- ggplot( perms, aes(diffMatrix, meanCorrDiff) ) + 
      geom_hline(yintercept=lpmean, color ="firebrick", linetype="dashed", size=1) + 
      labs(y="Mean of Correlation Difference Matrix Absolute Values", x="") + 
      scale_x_discrete(labels=c("Null Correlation Difference Matrices")) + 
      scale_y_continuous(limits = c(0.09, 0.1425), expand = c(0, 0), breaks=my_custom_values, labels = my_custom_labels) + 
      geom_jitter(color="forestgreen", size=0.4, alpha=0.1) + 
      geom_boxplot(outlier.shape=NA, color="forestgreen", width=0.25, alpha=0.7) + 
      geom_label(aes(1, 0.137625), label = "LIV-PM Correlation Difference Matrix", size=6,
                 show.legend = FALSE, color = "firebrick", label.size = NA,  data.frame()) +
      geom_label(aes(1, 0.105), label = "Null Correlation Difference Matrices", size=6,
                 show.legend = FALSE, color = "forestgreen", label.size = NA,  data.frame()) +
      geom_label(aes(1, 0.1213125), label = "empirical p-value < 0.0001", size=4, hjust=-0.05,
                 show.legend = FALSE, color = "black", label.size = NA,  data.frame()) +
      geom_segment(data = segment_data1, aes(x = xstart, y = ystart, xend = xend, yend = yend)) +
      geom_segment(data = segment_data2, aes(x = xstart, y = ystart, xend = xend, yend = yend), linetype="twodash") + 
      facet_grid(. ~ name) + 
      theme_bw() + 
      theme(panel.grid.major = element_blank(), 
            panel.grid.minor = element_blank(),
            strip.background =element_rect(fill="black"),
            strip.text = element_text(colour = 'white', size = 12),
            axis.text.x=element_blank(), 
            axis.ticks.x=element_blank(),
            axis.text.y = element_text(size=12) ) 
       ##     text=element_text(family="Arial") )

# combine
  layout <- c(
      area(1, 1, 6, 3),
      area(1, 4, 3, 6),
      area(4, 4, 6, 6)
  )

pdf("~/www/figures/lbp/lel2021_PRODUCTION/FORSUBMISSION/FIGURE3.pdf", h=8, w=10)
#(permz + px) / (p1 | p2)
#px + (p1/p2) + permz
#permz + px + gt + plot_layout(design = layout)
boxplot + p1 + p2 + plot_layout(design = layout)
dev.off()












#+END_SRC

#+NAME: DONE_make_figure
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)
  library(ggplot2)
  library(ggthemes)
  library(ggrepel)
  library(scales)
  library(rlang)
  library(assertthat)
  library(dplyr)
  library(magrittr)
  library(stringr)
  library(grid)
  library(gridExtra)
  library(egg)
  library(cowplot)
  library(patchwork)
  library(seriation)
  source("/sc/arion/projects/psychgen/lbp/scripts/lel2021_FigureFunctions.r") 
  setwd("/sc/arion/projects/psychgen/lbp/scratch/lel2021_livpm_corrMatrixDifferences/in")

# true mean
  lpmean <- 0.1402479

# perms
  perms <- fread("/sc/arion/projects/psychgen/lbp/scratch/lel2021_livpm_corrMatrixDifferences/permutations/10000perms_AllRand/combined.tsv", header=T)
  perms$diffMatrix <- as.factor(perms$diffMatrix)
  perms$greaterThanLPmean <- NA
  for (i in 1:nrow(perms)) {
      if (perms$meanCorrDiff[i]>lpmean) {
          perms$greaterThanLPmean[i] <- TRUE
      }
      else {
          perms$greaterThanLPmean[i] <- FALSE
      }
  }
  vertical_segment_data <- data.frame( #for geom_segment, tells it where to put the line segments
      x = c(0.099625, 0.137625), #(0.099 - 0.09725) + (0.14 - 0.137) = 0.00475/2 = 0.002375 on each side of the |---- emp p-val ----|
      xend = c(0.099625, 0.137625), 
      y = c(580, 580),
      yend = c(620, 620)
  )
  segment_data <- data.frame( #for geom_segment, tells it where to put the line segments, i.e., on each side of the geom_text p-value
      ##x = c(0.099625, 0.131625),
      ##xend = c(0.105625, 0.137625), 
      x = c(0.099625, 0.12725),
      xend = c(0.11, 0.137625), 
      y = c(600, 600),
      yend = c(600, 600)
  )
  perms[, name:= "Gene-Gene Correlation Difference Matrix Means"]

# degenrich
  degEnrich <- readRDS("/sc/arion/projects/psychgen/scratch/lbp_allBatches_RAPiD_FinalModel_forPaper_Figure4_cen-subsets_degEnrich_01NOV2021.RDS")
  lvMod <- degEnrich[livSig==TRUE,.N,conservedMod][N>=3]$conservedMod
  pmMod <- degEnrich[pmSig==TRUE,.N,conservedMod][N>=3]$conservedMod
  noMod <- unique(degEnrich$conservedMod)[!unique(degEnrich$conservedMod) %in% c(lvMod,pmMod)]
  lvVal <- degEnrich[conservedMod %in% lvMod,list(or=max(indexLvEstimate)),by=list(conservedMod)]
  pmVal <- degEnrich[conservedMod %in% pmMod,list(or=max(indexPmEstimate)),by=list(conservedMod)] #gives warning because there is no pmVal - its ok
  noVal <- degEnrich[conservedMod %in% noMod,list(or=max(indexPmEstimate)),by=list(conservedMod)]
  pmVal[,or:=-or]
  noVal[,or:=0]
  myOrd <- rbind(lvVal, pmVal, noVal)[order(or, decreasing=T)]$conservedMod
  degEnrich[,conservedMod:=factor(conservedMod, levels=myOrd)]
  degEnrich <- degEnrich[order(conservedMod)]
  degEnrich <- merge(degEnrich, data.table(conservedMod=myOrd, module=1:length(myOrd))) 
  degEnrich <- degEnrich[order(module)]
  xy1 <- degEnrich[(indexPmPvalAdj<0.05 | indexLvPvalAdj<0.05) & indexPmPvalAdj<indexLvPvalAdj, .(module, indexCEN, or=indexPmEstimate, p=indexPmPvalAdj, group="pm")]
  xy2 <- degEnrich[(indexPmPvalAdj<0.05 | indexLvPvalAdj<0.05) & indexLvPvalAdj<indexPmPvalAdj, .(module, indexCEN, or=indexLvEstimate, p=indexLvPvalAdj, group="lv")]
  xy3 <- degEnrich[(indexPmPvalAdj>0.05 & indexLvPvalAdj>0.05) , .(module, indexCEN, or=indexLvEstimate, p=indexLvPvalAdj, group="insig")]
  xy <- rbind(xy1, xy2, xy3) 
  xy[,myfacet:="LBP signature"]
  colOrd <- c("columbiaControl", "columbiaPD", "harvardControl", "harvardPD", "livNonPD", "livPD")
  xy[,indexCEN:=factor(indexCEN, colOrd)]
  xy[,group:=factor(group, levels=c("lv","insig"))]
  xz <- degEnrich[, .(module, indexCEN, or=kegOR, p=kegPADJ, group=kegTerm, myfacet="KEGG")]
  colOrd <- c("columbiaControl", "columbiaPD", "harvardControl", "harvardPD", "livNonPD", "livPD")
  xz[,indexCEN:=factor(indexCEN, colOrd)]
  keepme <- xy[group!="insig",.N,module]$module
  xy <- xy[module %in% keepme]
  xz <- xz[module %in% keepme]
  xy$title <- "LIV DEG Enrichment"
  xz$title <- "Top KEGG Gene Set Enrichment"
  xz$group <- factor(xz$group, levels=c("Ribosome", "Oxidative phosphorylation", "Non-coding RNAs"))

# boxplot 
  segment_data1 <- data.frame(
      xstart = c(1-0.025, 1-0.025),
      xend = c(1+0.025, 1+0.025), 
      ystart = c(0.107, 0.135625),
      yend = c(0.107, 0.135625)
  )
  segment_data2 <- data.frame(
      xstart = c(1),
      xend = c(1), 
      ystart = c(0.107),
      yend = c(0.135625)
  )
  my_custom_labels <- c("0.09","","","","","0.14")  
  my_custom_values <- c(0.09, 0.10, 0.11, 0.12, 0.13, 0.14)
  boxplot <- ggplot( perms, aes(diffMatrix, meanCorrDiff) ) + 
      geom_hline(yintercept=lpmean, color ="#E10032", linetype="dashed", size=1) + 
      labs(y="Mean of Correlation Difference Matrix Absolute Values", x="") + 
      scale_x_discrete(labels=c("Null Correlation Difference Matrices")) + 
      scale_y_continuous(limits = c(0.09, 0.1425), expand = c(0, 0), breaks=my_custom_values, labels = my_custom_labels) + 
      geom_jitter(color="forestgreen", size=0.4, alpha=0.1) + 
      geom_boxplot(outlier.shape=NA, color="forestgreen", width=0.25, alpha=0.7) + 
      geom_label(aes(1, 0.137625), label = "LIV-PM Correlation Difference Matrix", size=6,
                 show.legend = FALSE, color = "#E10032", label.size = NA,  data.frame()) +
      geom_label(aes(1, 0.105), label = "Null Correlation Difference Matrices", size=6,
                 show.legend = FALSE, color = "forestgreen", label.size = NA,  data.frame()) +
      geom_label(aes(1, 0.1213125), label = "empirical p-value < 0.0001", size=4, hjust=-0.05,
                 show.legend = FALSE, color = "black", label.size = NA,  data.frame()) +
      geom_segment(data = segment_data1, aes(x = xstart, y = ystart, xend = xend, yend = yend)) +
      geom_segment(data = segment_data2, aes(x = xstart, y = ystart, xend = xend, yend = yend), linetype="twodash") + 
      facet_grid(. ~ name) + 
      theme_bw() + 
      theme(panel.grid.major = element_blank(), 
            panel.grid.minor = element_blank(),
            strip.background =element_rect(fill="black"),
            strip.text = element_text(colour = 'white', size = 12),
            axis.text.x=element_blank(), 
            axis.ticks.x=element_blank(),
            axis.title.y = element_text(size=16), 
            axis.text.y = element_text(size=16) ) 

# top bar plot
  p1 <- ggplot(xy, aes(as.factor(module), or, group=indexCEN, fill=group)) + 
         geom_bar(col="black",stat="identity", position="dodge") +
         theme_bw() +
         ##scale_fill_manual(name = "", labels = c("Adjusted p-value < 0.05", "Adjusted p-value > 0.05"), values = c("#E5A298", "white")) +
         scale_fill_manual(name = "", labels = c("Adjusted p-value < 0.05", "Adjusted p-value > 0.05"), values = c("#A16AE8", "white")) +
         theme( panel.grid.major = element_blank(), 
            panel.grid.minor = element_blank(), 
            panel.background = element_blank(), 
            axis.line = element_line(colour = "black"), 
            legend.title = element_text(size = 10), 
            legend.text = element_text(size = 10), 
            #legend.position=c(.68,.25), 
            legend.position=c(.70,.8), 
            legend.background=element_blank(),
            axis.title.y = element_blank(), 
            axis.title.x = element_blank(), 
            text=element_text(size=16, family="ArialMT")) + 
       ##scale_y_discrete(labels = p1_labels) +
       facet_grid(. ~ title) + #to get the title of the plot in a grey box; this is a facet wrap "cheat"
       theme(strip.background =element_rect(fill="black")) + #to change the color of the grey box from grey to something else
       theme(strip.text = element_text(colour = 'white', size = 12)) + #to change the text inside the grey box 
       scale_y_continuous(limits = c(0, 19), expand = c(0, 0)) #this line removes the space between the y axis 0 and the x axis

# bottom bar plot
  p2 <- ggplot(xz, aes(as.factor(module), or, group=indexCEN, fill=group)) + 
      geom_bar(col="black",stat="identity", position="dodge") + theme_bw() +
      theme(panel.grid.major = element_blank(), 
            panel.grid.minor = element_blank(), 
            panel.background = element_blank(), 
            axis.line = element_line(colour = "black"), 
            legend.title = element_text(size = 10), 
            legend.text = element_text(size = 10), 
            #legend.position=c(.70,.25), 
            legend.position=c(.70,.8), 
            legend.background=element_blank(),
            axis.title.x = element_text(size=16), 
            text = element_text(size=16, family="ArialMT")) +
            xlab("Conserved Network Structure") +
      ##scale_y_discrete(breaks = NULL, labels = NULL) + #scale_fill_discrete(name = "") + 
      scale_fill_manual(name = "", values=c("#ECF87F", "#75E6DA", "#BAC6AD")) + 
      ##scale_fill_manual(name = "", values=c("#F49728", "#75E6DA", "#BAC6AD")) + 
      ##scale_fill_manual(name = "", values=c("#00BA38", "#F8766D", "#C77CFF")) + ###CHANGE COLORS
      facet_grid(. ~ title) + ylab("") + # + xlab("Odds Ratio")  
      theme(strip.background =element_rect(fill="black")) + #to change the color of the grey box from grey to something else
      theme(strip.text = element_text(colour = 'white', size = 12)) + #to change the text inside the grey box 
      scale_y_continuous(limits = c(0, 320), expand = c(0, 0)) #this line removes the space between the y axis 0 and the x axis

# combine bar plots 
  p12 <- p1 / p2
  barplots <- patchwork::patchworkGrob(p12)
  barplots <- gridExtra::grid.arrange(barplots, 
                                      left = textGrob("Odds Ratio", vjust=2.7, rot=90, gp=gpar(fontsize=16)))

# combine
  layout2 <- c(
      area(1, 1, 6, 3),
      area(1, 4, 6, 6)
  )

# save
  pdf("~/www/figures/lbp/lel2021_PRODUCTION/FORSUBMISSION/FIGURE3.pdf", h=8, w=10)
    #(permz + px) / (p1 | p2)
    #px + (p1/p2) + permz
    #permz + px + gt + plot_layout(design = layout)
    #boxplot + barplots + plot_layout(design = layout)
    boxplot + barplots + plot_layout(design = layout2)
  dev.off()


#+END_SRC



* FOR SUBMISSION - f4 - "disease figure"

#+NAME: DONE_alz1_de
#+BEGIN_SRC R

##
## Note on MSBB covariates data:
##   The path used no longer exists: /hpc/users/beckmn01/AMP-AD/info_all_AMP-AD_corrected_final_redone_best_only.RDS 
##   However, from code in lbp.org can see that 
##       a processed/reformatted version of the object previously stored in that path was put in
##       the mydata object mydata[["covariates"]][["amp"]][["amp|10|PlaqueMean"]] at: 
##           /sc/arion/projects/psychgen/lbp/data/rna/lbp_hbc_cmc_amp_exp_and_cov.Rdata
##   The processing steps were 
##       - subset for samples in resVP
##       - column classes were specified as numeric, factor, or character
##       - kept samples without NA values in PlaqueMean column
##   Storing that processed table at 
##       saveRDS(mydata[["covariates"]][["amp"]][["amp|10|PlaqueMean"]], file="/sc/arion/projects/psychgen/lbp/data/rna/alz1_info_all_MSSM.RDS")
##

# setup 
  rm(list=ls())
  library(data.table)
  library(limma)
  library(edgeR)

# expression data
  myexp <- load("/sc/arion/projects/adineto/Noam/residuals/residuals_MSSM_Batch_for_correct_VP_without_outliers_RIN_larger_equal_4_best_only.RData")
  myexp <- get(myexp)

# covariate data
  mycov <- readRDS("/sc/arion/projects/psychgen/lbp/data/rna/alz1_info_all_MSSM.RDS")
  mycov.covlist = c("PlaqueMean", "PMI", "RACE", "correct_SEX", "RIN", "Exonic.Rate")
  mycov <- mycov[,mycov.covlist]
  mycov.formula <- as.formula(paste("~",paste(mycov.covlist,collapse="+")))

# match ids
  myexp <- myexp[,rownames(mycov)]
  identical(rownames(mycov),colnames(myexp)) #[1] TRUE
  dim(myexp) #[1] 24865   246

# de
  mydesign <- model.matrix(mycov.formula, mycov)
  colnames(mydesign) <- make.names(colnames(mydesign))
  mylmgroup <- lmFit(myexp, mydesign)
  mylmgroup_DE <- eBayes(mylmgroup)
  mycoefcol <- which(gregexpr("PlaqueMean", colnames(mydesign))>0)
  myGroup_DE_tab <- topTable(mylmgroup_DE, coef=mycoefcol, number=nrow(mylmgroup_DE))
  de <- data.table( gene = rownames(myGroup_DE_tab), myGroup_DE_tab)
  saveRDS(de, file="/sc/arion/projects/psychgen/lbp/results/lel2021_alz1_de_results.RDS")

# sanity check that this gets you identical result as what is stored in mydata
  load("/sc/arion/projects/psychgen/lbp/data/rna/lbp_hbc_cmc_amp_exp_and_cov.Rdata") #mydata
  test <- mydata$datasets[["amp|10|PlaqueMean"]]$de$noNEUcorr.noLBPcorr
  nrow(de) #[1] 24865
  nrow(test) #[1] 24865
  test <- merge(de, test, by="gene") 
  nrow(test) #[1] 24865
  nrow(test[logFC.x != logFC.y]) #[1] 0

#+END_SRC

#+NAME: DONE_alz2_de
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)
  library(limma)
  library(edgeR)

# expression data
  myexp <- readRDS("/sc/arion/projects/adineto/Noam/AMPAD_all_data/Rosmap/expression/voom_normalized_counts.RDS")

# covariate data
  mycov <- as.data.table(readRDS("/sc/arion/projects/adineto/Noam/AMPAD_all_data/Rosmap/covariates/info_all.RDS"))
  mycov.covlist <- c("ceradscBin", "Batch", "RINcontinuous", "RnaSeqMetrics__MEDIAN_5PRIME_TO_3PRIME_BIAS", "msex",
                     "AlignmentSummaryMetrics__STRAND_BALANCE", "RnaSeqMetrics__PCT_INTRONIC_BASES", "pmi")
  mycov[ ceradsc=="1", ceradsc:="AD"]
  mycov[ ceradsc=="2", ceradsc:="ADPROB"]
  mycov[ ceradsc=="3", ceradsc:="ADPOSS"]
  mycov[ ceradsc=="4", ceradsc:="Control"]
  mycov[ ceradsc == "AD", ceradscBin := 1 ]
  mycov[ ceradsc == "Control", ceradscBin := 0 ]
  table(mycov$race, mycov$ceradscBin)
  ##    0   1
  ##1 162 183
  ##2   3   3
  ##3   0   0
  ##6   0   1
  mycov <- mycov[race==1] 
  mykep <- make.names(mycov[!is.na(ceradscBin)]$sample)
  length(mykep) #[1] 345
  mycov <- as.data.frame(mycov)
  rownames(mycov) <- make.names(mycov$sample)
  mycov <- mycov[mykep,mycov.covlist]
  mycov.formula <- as.formula(paste("~",paste(mycov.covlist,collapse="+")))

# match ids
  mykp2 <- intersect(colnames(myexp), rownames(mycov))
  length(mykp2) #[1] 345
  identical(mykep, mykp2) #[1] TRUE
  myexp <- myexp[,mykep]
  mycov <- mycov[mykep,]
  identical(rownames(mycov),colnames(myexp)) #[1] TRUE

# de
  mydesign <- model.matrix(mycov.formula, mycov)
  colnames(mydesign) <- make.names(colnames(mydesign))
  length(rownames(mydesign)) #[1] 343
  dim(myexp) #[1] 19466   345
  myexp <- myexp[,rownames(mydesign)]
  dim(myexp) #[1] 19466   343
  table(mydesign[,"ceradscBin"])
  ##  0   1 
  ##162 181 
  mylmgroup <- lmFit(myexp$E, mydesign)
  mylmgroup_DE <- eBayes(mylmgroup)
  mycoefcol <- which(gregexpr("ceradscBin", colnames(mydesign))>0)
  myGroup_DE_tab <- topTable(mylmgroup_DE, coef=mycoefcol, number=nrow(mylmgroup_DE))
  de <- data.table( gene = rownames(myGroup_DE_tab), myGroup_DE_tab)
  saveRDS(de, file="/sc/arion/projects/psychgen/lbp/results/lel2021_alz2_de_results.RDS")


# sanity check that this gets you identical result as what is stored in mydata
  load("/sc/arion/projects/psychgen/lbp/data/rna/lbp_hbc_cmc_amp_exp_and_cov.Rdata") #mydata
  test <- mydata$datasets[["ros"]]$de$noNEUcorr.noLBPcorr
  nrow(de) #[1] 19466
  nrow(test) #[1] 19466
  test <- merge(de, test, by="gene") 
  nrow(test) #[1] 19466
  nrow(test[logFC.x != logFC.y]) #[1] 0

#+END_SRC

#+NAME: DONE_scz1_de
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)
  library(limma)
  library(edgeR)

# expression data
  myexp <- load("/sc/arion/projects/adineto/Noam/AMPAD_all_data/schizo/HBCC_PFC/expression/residualsFlowcellBatch_no_outliers.RData")
  myvob <- readRDS("/sc/arion/projects/adineto/Noam/AMPAD_all_data/schizo/HBCC_PFC/expression/voom_normalized_counts_no_outliers.RDS")
  myexp <- get(myexp)
  colnames(myexp) <- colnames(myvob)
  rownames(myexp) <- rownames(myvob)

# covariate data
  mycov <- readRDS("/sc/arion/projects/adineto/Noam/AMPAD_all_data/schizo/HBCC_PFC/covariates/info_all.RDS")
  mycov[Dx=="Control",scz:=0]
  mycov[Dx=="SCZ",scz:=1]
  mycov.covlist = c("scz", "RIN", "IntronicRate", "Gender", "Age_of_Death", "PMI", "GenesDetected", "TotalReads", "IntergenicRate")
  mycov <- mycov[!is.na(scz)]
  mykep <- intersect( as.character(mycov$SampleID), colnames(myexp) )
  mycov <- as.data.frame(mycov)
  rownames(mycov) <- make.names(mycov$SampleID)
  mycov <- mycov[mykep,mycov.covlist]
  mycov.formula <- as.formula(paste("~ ", paste(c("scz", mycov.covlist), collapse = " + ")))
  length(mykep) #[1] 309

# match ids
  myexp <- myexp[,mykep]
  mycov <- mycov[mykep,]
  identical(rownames(mycov),colnames(myexp)) #[1] TRUE

# de
  mydesign <- model.matrix(mycov.formula, mycov)
  colnames(mydesign) <- make.names(colnames(mydesign))
  length(rownames(mydesign)) #[1] 309
  dim(myexp) #[1] 22468   309
  myexp <- myexp[,rownames(mydesign)]
  dim(myexp) #[1] 22468   309
  table(mydesign[,"scz"])
  ##  0   1 
  ##213  96
  mylmgroup <- lmFit(myexp, mydesign)
  mylmgroup_DE <- eBayes(mylmgroup)
  mycoefcol <- which(gregexpr("scz", colnames(mydesign))>0)
  myGroup_DE_tab <- topTable(mylmgroup_DE, coef=mycoefcol, number=nrow(mylmgroup_DE))
  de <- data.table( gene = rownames(myGroup_DE_tab), myGroup_DE_tab)
  saveRDS(de, file="/sc/arion/projects/psychgen/lbp/results/lel2021_scz1_de_results.RDS")

# sanity check that this gets you identical result as what is stored in mydata
  load("/sc/arion/projects/psychgen/lbp/data/rna/lbp_hbc_cmc_amp_exp_and_cov.Rdata") #mydata
  test <- mydata$datasets[["hbc|pfc|scz"]]$de$noNEUcorr.noLBPcorr
  nrow(de) #[1] 22468
  nrow(test) #[1] 22460
  test <- merge(de, test, by="gene") 
  nrow(test) #[1] 22460
  nrow(test[logFC.x != logFC.y]) #[1] 22460

#+END_SRC

#+NAME: DONE_scz2_de
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)
  library(limma)
  library(edgeR)

# expression data
  myexp <- load("/sc/arion/projects/adineto/Noam/AMPAD_all_data/schizo/CMC_PFC/expression/residualsLibraryBatch_no_outliers.RData")
  myvob <- readRDS("/sc/arion/projects/adineto/Noam/AMPAD_all_data/schizo/CMC_PFC/expression/voom_normalized_counts_no_outliers.RDS")
  myexp <- get(myexp)
  colnames(myexp) <- colnames(myvob)
  rownames(myexp) <- rownames(myvob)
  dim(myexp) #[1] 22792   516

# covariate data
  mycov <- readRDS("/sc/arion/projects/adineto/Noam/AMPAD_all_data/schizo/CMC_PFC/covariates/info_all.RDS")
  mycov[Dx=="Control",scz:=0]
  mycov[Dx=="SCZ",scz:=1]
  mycov.covlist = c("scz", "BANK", "RIN", "ExonicRate", "IntragenicRate", "GenesDetected", "Gender", "PMI", "Age_of_Death", "MappedReads")
  mycov <- mycov[!is.na(scz)]
  mykep <- intersect( as.character(mycov$SampleID), colnames(myexp) )
  mycov <- as.data.frame(mycov)
  rownames(mycov) <- make.names(mycov$SampleID)
  mycov <- mycov[mykep,mycov.covlist]
  mycov.formula <- as.formula(paste("~ ", paste(c("scz", mycov.covlist), collapse = " + ")))
  length(mykep) #[1] 474

# cmc and ampad overlaps
  myraw <- readRDS("/sc/arion/projects/adineto/Noam/AMPAD_all_data/schizo/CMC_PFC/covariates/info_all.RDS")
  x1 <- "/sc/arion/projects/psychgen/methods/gdde/data/dna/OLD/combined/mer.hg19.sharedsnps.fixed.pr.gtcheck.out.ERR"
  x2 <- "/sc/arion/projects/psychgen/methods/gdde/data/dna/OLD/combined/mer.hg19.sharedsnps.fixed.pr.gtcheck.out.CN"
  err <- fread(x1)[,.(id1=V4, id2=V5, err=V2, nsites=V3)]
  cnn <- fread(x2)[,.(id1=V5, id2=V6, dis=V2, nsites=V3)]
  mer <- merge(err, cnn)
  mat <- mer[err<0.2]
  cmcamp <- unique(gsub("cmc_", "", mat[grep("cmc", id2)]$id2))
  rmme <-  myraw[Individual_ID %in% cmcamp]$SampleID

# match ids
  mykep <- mykep[!mykep %in% rmme]  
  myexp <- myexp[,mykep]
  mycov <- mycov[mykep,]
  identical(rownames(mycov),colnames(myexp)) #[1] TRUE

# de
  mydesign <- model.matrix(mycov.formula, mycov)
  colnames(mydesign) <- make.names(colnames(mydesign))
  length(rownames(mydesign)) #[1] 414
  dim(myexp) #[1] 22792   414
  myexp <- myexp[,rownames(mydesign)]
  dim(myexp) #[1] 22792   414
  table(mydesign[,"scz"])
  ##  0   1 
  ##187 227
  mylmgroup <- lmFit(myexp, mydesign)
  mylmgroup_DE <- eBayes(mylmgroup)
  mycoefcol <- which(gregexpr("scz", colnames(mydesign))>0)
  myGroup_DE_tab <- topTable(mylmgroup_DE, coef=mycoefcol, number=nrow(mylmgroup_DE))
  de <- data.table( gene = rownames(myGroup_DE_tab), myGroup_DE_tab)
  saveRDS(de, file="/sc/arion/projects/psychgen/lbp/results/lel2021_scz2_de_results.RDS")

# sanity check that this gets you identical result as what is stored in mydata
  load("/sc/arion/projects/psychgen/lbp/data/rna/lbp_hbc_cmc_amp_exp_and_cov.Rdata") #mydata
  test <- mydata$datasets[["cmc|pfc|scz"]]$de$noNEUcorr.noLBPcorr
  nrow(de) #[1] 22792
  nrow(test) #[1] 22792
  test <- merge(de, test, by="gene") 
  nrow(test) #[1] 22792
  nrow(test[logFC.x != logFC.y]) #[1] 0

#+END_SRC

#+NAME: DONE_pd_de_by_bank
#+BEGIN_SRC R

# setup
  rm(list=ls())
  options(stringsAsFactors=F)
  suppressMessages(library(readxl))
  suppressMessages(library(data.table))
  suppressMessages(library(variancePartition))
  suppressMessages(library(limma))
  suppressMessages(library(edgeR))
  suppressMessages(library(Glimma))
  suppressMessages(library(BiocParallel))
  Sys.setenv(OMP_NUM_THREADS = 6)

# read in lbp data
  lbp <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")
  met <- lbp$covariates
  vob <- lbp$vobjDream

# master phe table 
  myfile <- "/sc/arion/projects/psychgen/lbp/files/sema4_bulk_rna_sample_sheet/Bulk_RNA_Isolation_Mastertable_BRAINANDBLOOD.xlsx"
  mycoltypes <- c(rep("text", 8),"numeric",rep("text",6),"date","text","date","text",rep("numeric",4),rep("text",2))
  myna <- c("NA","na","",".","n/a","N/A","unknown","89+")
  phe <- as.data.table(read_excel(myfile, sheet=1, col_names = TRUE, col_types = mycoltypes, na=myna))
  phe <- unique(phe[,.(IID_ISMMS=iid, SAMPLE_ISMMS=LBPSEMA4_ID, PD=phe)])
  badControl <- phe[PD %in% c("Dyt", "ET", "AD")]$SAMPLE_ISMMS

# pm pd cases and controls
  hvk <- met[mymet_bank=="Harvard" & mymet_phe=="PD"]$SAMPLE_ISMMS
  hvc <- met[mymet_bank=="Harvard" & mymet_phe=="Control"]$SAMPLE_ISMMS
  clk <- met[mymet_bank=="Columbia" & mymet_phe=="PD"]$SAMPLE_ISMMS
  clc <- met[mymet_bank=="Columbia" & mymet_phe=="Control"]$SAMPLE_ISMMS
  length(hvk) #[1] 50
  length(hvc) #[1] 54
  length(clk) #[1] 74
  length(clc) #[1] 52
  hvc <- hvc[!hvc %in% badControl]
  clc <- clc[!clc %in% badControl]
  length(hvc) #[1] 54
  length(clc) #[1] 37

# update metadata
  met[,de:="notassigned"]
  met[SAMPLE_ISMMS %in% hvk, de:="HAR_CASE"]
  met[SAMPLE_ISMMS %in% hvc, de:="HAR_CTRL"]
  met[SAMPLE_ISMMS %in% clk, de:="COL_CASE"]
  met[SAMPLE_ISMMS %in% clc, de:="COL_CTRL"]
  met[,de:=as.factor(de)]
  met <- as.data.frame(met)
  rownames(met) <- met$SAMPLE_ISMMS

# formula
  form <- ~0 + de + (1|mymet_sex) + mymet_rin + neuronal + RNASeqMetrics_MEDIAN_3PRIME_BIAS + 
              RNASeqMetrics_PCT_MRNA_BASES + (1|IID_ISMMS) + (1|mymet_depletionbatch) + 
              InsertSizeMetrics_MEDIAN_INSERT_SIZE + AlignmentSummaryMetrics_STRAND_BALANCE_FIRST_OF_PAIR

# sanity check
  identical(rownames(met), colnames(vob$E)) #[1] TRUE

# contrasts
  harCon <- getContrast(vob, form, met, c(paste0("de","HAR_CASE"), paste0("de","HAR_CTRL")))
  colCon <- getContrast(vob, form, met, c(paste0("de","COL_CASE"), paste0("de","COL_CTRL")))
  L <- cbind(harCon,colCon)

# de
  fitmm <- dream( vob, form, met, L, BPPARAM = MulticoreParam(5))

# format de results
  harDe <- topTable(fitmm, coef="harCon", number=nrow(vob))
  colDe <- topTable(fitmm, coef="colCon", number=nrow(vob))
  harDe <- data.table(gene = rownames(harDe), harDe)[order(logFC)]
  colDe <- data.table(gene = rownames(colDe), colDe)[order(logFC)]
  harDe[, DEG:="NOTDEG"]
  colDe[, DEG:="NOTDEG"]
  harDe[adj.P.Val<0.05, DEG:="DEG"]
  colDe[adj.P.Val<0.05, DEG:="DEG"]
  harDe[logFC<0, LFC:="NEGLFC"]
  harDe[logFC>0, LFC:="POSLFC"]
  colDe[logFC<0, LFC:="NEGLFC"]
  colDe[logFC>0, LFC:="POSLFC"]
  harl.m <- as.data.table(rowMeans(vob$E[,hvk]), keep.rownames=T)[,.(gene=V1, HAR_CASE=V2)]
  harp.m <- as.data.table(rowMeans(vob$E[,hvc]), keep.rownames=T)[,.(gene=V1, HAR_CTRL=V2)]
  coll.m <- as.data.table(rowMeans(vob$E[,clk]), keep.rownames=T)[,.(gene=V1, COL_CASE=V2)]
  colp.m <- as.data.table(rowMeans(vob$E[,clc]), keep.rownames=T)[,.(gene=V1, COL_CTRL=V2)]
  harDe <- merge(merge(harDe, harl.m), harp.m)
  colDe <- merge(merge(colDe, coll.m), colp.m)
  harDe[HAR_CASE>HAR_CTRL,greaterExpression:="case"]
  harDe[HAR_CASE<HAR_CTRL,greaterExpression:="ctrl"]
  colDe[COL_CASE>COL_CTRL,greaterExpression:="case"]
  colDe[COL_CASE<COL_CTRL,greaterExpression:="ctrl"]

# correlate logFC values
  x1 <- harDe[,.(gene, logFC.pdh=logFC)] 
  x2 <- colDe[,.(gene, logFC.pdc=logFC)] 
  x3 <- lbp$livpmDE[,.(gene,logFC.lbp=logFC)]
  mx <- merge(merge(x1, x2), x3)
  cor(mx$logFC.pdh, mx$logFC.pdc, method="spearman") #[1] 0.6565169
  cor(mx$logFC.lbp, mx$logFC.pdh, method="spearman") #[1] 0.6312932 
  cor(mx$logFC.lbp, mx$logFC.pdc, method="spearman") #[1] 0.452058

# save 
  saveRDS(list("PMPDDE_HAR"=harDe, "PMPDDE_COL"=colDe),
          file="/sc/arion/projects/psychgen/lbp/results/lel2021_pmpd_bank_22OCT2021.RDS")
  
#+END_SRC

#+NAME: DONE_pd_de_full
#+BEGIN_SRC R

# setup
  rm(list=ls())
  options(stringsAsFactors=F)
  suppressMessages(library(readxl))
  suppressMessages(library(data.table))
  suppressMessages(library(variancePartition))
  suppressMessages(library(limma))
  suppressMessages(library(edgeR))
  suppressMessages(library(Glimma))
  suppressMessages(library(BiocParallel))
  suppressMessages(library(qvalue))
  Sys.setenv(OMP_NUM_THREADS = 6)

# read in lbp data
  lbp <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")
  met <- lbp$covariates
  vob <- lbp$vobjDream

# master phe table 
  myfile <- "/sc/arion/projects/psychgen/lbp/files/sema4_bulk_rna_sample_sheet/Bulk_RNA_Isolation_Mastertable_BRAINANDBLOOD.xlsx"
  mycoltypes <- c(rep("text", 8),"numeric",rep("text",6),"date","text","date","text",rep("numeric",4),rep("text",2))
  myna <- c("NA","na","",".","n/a","N/A","unknown","89+")
  phe <- as.data.table(read_excel(myfile, sheet=1, col_names = TRUE, col_types = mycoltypes, na=myna))
  phe <- unique(phe[,.(IID_ISMMS=iid, SAMPLE_ISMMS=LBPSEMA4_ID, PD=phe)])
  badControl <- phe[PD %in% c("Dyt", "ET", "AD")]$SAMPLE_ISMMS

# pm pd cases and controls
  pdk <- met[mymet_postmortem==1 & mymet_phe=="PD"]$SAMPLE_ISMMS
  pdc <- met[mymet_postmortem==1 & mymet_phe=="Control"]$SAMPLE_ISMMS
  length(pdk) #[1] 132
  length(pdc) #[1] 111
  pdc <- pdc[!pdc %in% badControl]
  length(pdc) #[1] 96

# update metadata
  met[,de:="notassigned"]
  met[SAMPLE_ISMMS %in% pdk, de:="PD"]
  met[SAMPLE_ISMMS %in% pdc, de:="CTRL"]
  met[,de:=as.factor(de)]
  met <- as.data.frame(met)
  rownames(met) <- met$SAMPLE_ISMMS

# formula
  form <- ~0 + de + (1|mymet_sex) + (1|mymet_bank) + mymet_rin + neuronal + RNASeqMetrics_MEDIAN_3PRIME_BIAS + 
              RNASeqMetrics_PCT_MRNA_BASES + (1|IID_ISMMS) + (1|mymet_depletionbatch) + 
              InsertSizeMetrics_MEDIAN_INSERT_SIZE + AlignmentSummaryMetrics_STRAND_BALANCE_FIRST_OF_PAIR

# sanity check
  identical(rownames(met), colnames(vob$E)) #[1] TRUE

# contrasts
  L <- getContrast(vob, form, met, c(paste0("de","PD"), paste0("de","CTRL")))

# de
  fitmm <- dream( vob, form, met, L, BPPARAM = MulticoreParam(5))

# format de results
  pdDe <- topTable(fitmm, coef="L1", number=nrow(vob))
  pdDe <- data.table(gene = rownames(pdDe), pdDe)

  pdDe[, DEG:="NOTDEG"]
  pdDe[adj.P.Val<0.05, DEG:="DEG"]
  pdDe[logFC<0, LFC:="NEGLFC"]
  pdDe[logFC>0, LFC:="POSLFC"]
  case.m <- as.data.table(rowMeans(vob$E[,pdk]), keep.rownames=T)[,.(gene=V1, PD=V2)]
  ctrl.m <- as.data.table(rowMeans(vob$E[,pdc]), keep.rownames=T)[,.(gene=V1, CTRL=V2)]
  pdDe <- merge(merge(pdDe, case.m), ctrl.m)
  pdDe[PD>CTRL,greaterExpression:="case"]
  pdDe[PD<CTRL,greaterExpression:="ctrl"]

# save 
  saveRDS(pdDe, file="/sc/arion/projects/psychgen/lbp/results/lel2021_pmpd_full_30NOV2021.RDS")

#+END_SRC

#+NAME: DONE_pi1_for_lbp_alz_scz_pd
#+BEGIN_SRC R

# setup
  rm(list=ls())
  options(stringsAsFactors=F)
  suppressMessages(library(data.table))
  suppressMessages(library(qvalue))

# lbp de
  lbp <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")$livpmDE  
  lbh <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_bank_14OCT2021.RDS")$LIVPMDE_HAR
  lbc <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_bank_14OCT2021.RDS")$LIVPMDE_COL

# alz de
  az1 <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_alz1_de_results.RDS") #msbb
  az2 <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_alz2_de_results.RDS") #rosmap

# scz de
  sz1 <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_scz1_de_results.RDS") #hbcc
  sz2 <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_scz2_de_results.RDS") #cmc

# pd de
  pdk <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_pmpd_full_30NOV2021.RDS") #all lbp pm pd
  pdh <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_pmpd_bank_22OCT2021.RDS")$PMPDDE_HAR #harvard 
  pdc <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_pmpd_bank_22OCT2021.RDS")$PMPDDE_COL #columbia

# pi1 
  1 - pi0est(lbp$P.Value)$pi0 #[1] 0.8703588 ... liv vs pm - all samples
  1 - pi0est(lbh$P.Value)$pi0 #[1] 0.8139239 ... liv vs pm - half liv and harvard pm
  1 - pi0est(lbc$P.Value)$pi0 #[1] 0.858748  ... liv vs pm - half liv and columbia pm
  1 - pi0est(az1$P.Value)$pi0 #[1] 0.3017005 ... alz vs con - msbb plaquemean
  1 - pi0est(az2$P.Value)$pi0 #[1] 0.461751  ... alz vs con - rosmap cerad
  1 - pi0est(sz1$P.Value)$pi0 #[1] 0.3841477 ... scz vs con - hbcc 
  1 - pi0est(sz2$P.Value)$pi0 #[1] 0.2108851 ... scz vs con - cmc
  1 - pi0est(pdk$P.Value)$pi0 #[1] 0.7155688 ... pd vs con - all lbp pm
  1 - pi0est(pdh$P.Value)$pi0 #[1] 0.6737183 ... pd vs con - harvard lbp pm
  1 - pi0est(pdc$P.Value)$pi0 #[1] 0.5415119 ... pd vs con - columbia lbp pm

# ndeg
  nrow(lbp[DEG=="DEG"]) #[1] 17186
  nrow(lbh[DEG=="DEG"]) #[1] 15203
  nrow(lbc[DEG=="DEG"]) #[1] 16060
  nrow(az1[adj.P.Val<0.05]) #[1] 680
  nrow(az2[adj.P.Val<0.05]) #[1] 2129
  nrow(sz1[adj.P.Val<0.05]) #[1] 1623
  nrow(sz2[adj.P.Val<0.05]) #[1] 37
  nrow(pdk[DEG=="DEG"]) #[1] 11542
  nrow(pdh[DEG=="DEG"]) #[1] 9930
  nrow(pdc[DEG=="DEG"]) #[1] 5075

#+END_SRC

#+NAME: DONE_differential_pd_module_enrichment
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)
  library(ggplot2)
  library(ggthemes)
  library(ggpubr)
  library(stringr)
  source("/hpc/users/charna02/www/figures/lbp/lel2021_PRODUCTION/FIGURE_FUNCTIONS.r")

# coexpression data
  cenList <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_subsets.RDS")
  cenList$livNonPD <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_livnonpd.RDS") 
  ##cenFish <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_subsets_overlap.RDS")
  cenFish <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_subsets_overlap_withLivNonpd.RDS")
  cenCombos <- as.data.table(t(combn(names(cenList), 2) ))

# find best module-module matches between network pairs
  myBest <- c()
  for (i in 1:nrow(cenCombos)){
      print(i)
      c1 <- cenCombos[i]$V1
      c2 <- cenCombos[i]$V2
      mod <- list( unique(cenList[[c1]]$module), unique(cenList[[c2]]$module) )
      names(mod) <- c(c1, c2)
      for (j in c(c1, c2)){
          if (j==c1) other <- c2
          if (j==c2) other <- c1
          for (k in mod[[j]]){
              if (j==c1){
                  cur <- cenFish[cen1==j & cen2==other & mod1==k][order(fisher.p)][1]
                  idx.cen <- j
                  com.cen <- other
                  idx.mod <- k
                  com.mod <- cur$mod2
                  idx.mod.size <- cur$mod1.size
                  com.mod.size <- cur$mod2.size
              } else {
                  cur <- cenFish[cen2==j & cen1==other & mod2==k][order(fisher.p)][1]
                  idx.cen <- j
                  com.cen <- other
                  idx.mod <- k
                  com.mod <- cur$mod1
                  idx.mod.size <- cur$mod2.size
                  com.mod.size <- cur$mod1.size
              }
              add <- data.table( indexCEN=idx.cen, compareCEN=com.cen,
                                indexMod=idx.mod, compareMod=com.mod,
                                indexModSize=idx.mod.size, compareModSize=com.mod.size,
                                fisher.estimate=cur$fisher.estimate, fisher.p=cur$fisher.p,
                                fisher.p.adjust=cur$fisher.p.adjust )
              myBest <- rbind(myBest, add)                       
          }            
      }
  }
  ##
  ## some formatting (may not be used later, cant remember)
  ##
  myBest[grep("har", indexCEN),indexBank:="HVD"]
  myBest[grep("col", indexCEN),indexBank:="CBA"]
  myBest[grep("liv", indexCEN),indexBank:="LBP"]
  myBest[grep("har", compareCEN),compareBank:="HVD"]
  myBest[grep("col", compareCEN),compareBank:="CBA"]
  myBest[grep("liv", compareCEN),compareBank:="LBP"]
  myBest[grep("Control", indexCEN),indexPhe:="CON"]
  myBest[grep("Control", compareCEN),comparePhe:="CON"]
  myBest[grep("PD", indexCEN),indexPhe:="PD"]
  myBest[grep("PD", compareCEN),comparePhe:="PD"]
  myBest[grep("NonPD", indexCEN),indexPhe:="NONPD"]
  myBest[grep("NonPD", compareCEN),comparePhe:="NONPD"]
  myBest[ (indexBank=="HVD" & compareBank=="LBP"), bankPair:="PM-LIV"]
  myBest[ (indexBank=="LBP" & compareBank=="HVD"), bankPair:="LIV-PM"]
  myBest[ (indexBank=="CBA" & compareBank=="LBP"), bankPair:="PM-LIV"]
  myBest[ (indexBank=="LBP" & compareBank=="CBA"), bankPair:="LIV-PM"]
  myBest[ (indexBank=="HVD" & compareBank=="CBA") | (indexBank=="CBA" & compareBank=="HVD"), bankPair:="PM-PM"]
  myBest[ (indexBank=="HVD" & compareBank=="HVD") | (indexBank=="CBA" & compareBank=="CBA"), bankPair:="PM-PM"]
  myBest[ (indexBank=="LBP" & compareBank=="LBP"), bankPair:="LIV-LIV"]
  myBest[ (indexPhe=="CON" & comparePhe=="CON"), phePair:="CON-CON"]
  myBest[ (indexPhe=="PD" & comparePhe=="PD"), phePair:="PD-PD"]
  myBest[ (indexPhe=="PD" & comparePhe=="CON"), phePair:="PD-CON"]
  myBest[ (indexPhe=="CON" & comparePhe=="PD"), phePair:="CON-PD"]
  myBest[ (indexPhe=="PD" & comparePhe=="NONPD"), phePair:="PD-NONPD"]
  myBest[ (indexPhe=="NONPD" & comparePhe=="PD"), phePair:="NONPD-PD"]
  myBest[ (indexPhe=="CON" & comparePhe=="NONPD"), phePair:="CON-NONPD"]
  myBest[ (indexPhe=="NONPD" & comparePhe=="CON"), phePair:="NONPD-CON"]

# find conserved modules for network groups of interest

  ## remove instances where grey module is part of a match (since these arent conserved modules)
  nogrey <- myBest[indexMod!="grey" & compareMod!="grey"]

  ## define network groups of interest (eg, all PD networks, all PM PD networs, etc)
  allcas <- c("livPD","columbiaPD","harvardPD")  
  dedall <- c("columbiaPD","harvardPD","columbiaControl", "harvardControl")  
  dedcas <- c("columbiaPD","harvardPD")
  livcon <- c("livPD","columbiaControl", "harvardControl") ##livNonPD"
  allall <- c("livPD","columbiaPD","harvardPD","columbiaControl", "harvardControl") ##livNonPD",
  livliv <- c("livPD","livNonPD")

  ## find conserved modules
  mcnLcn <- findConsensusModules( stats = nogrey, nets = livcon, refnet =  livcon[1], cenlist = cenList)
  mcnAll <- findConsensusModules( stats = nogrey, nets = allall, refnet =  allall[1], cenlist = cenList)
  mcnPmt <- findConsensusModules( stats = nogrey, nets = dedall, refnet =  dedall[1], cenlist = cenList)
  mcnPkd <- findConsensusModules( stats = nogrey, nets = allcas, refnet =  allcas[1], cenlist = cenList)
  mcnPpd <- findConsensusModules( stats = nogrey, nets = dedcas, refnet =  dedcas[1], cenlist = cenList)
  mcnLiv <- findConsensusModules( stats = nogrey, nets = livliv, refnet =  livliv[1], cenlist = cenList)
  pmall <- mcnPmt$meta[,.(x=paste(columbiaPD,harvardPD))]$x #modules conserved in all pm networks
  pdall <- mcnPkd$meta[,.(x=paste(columbiaPD,harvardPD))]$x #modules conserved in all pd networks
  pmpkd <- mcnPpd$meta[,.(x=paste(columbiaPD,harvardPD))]$x #modules conserved in pm pd networks
  inal5 <- mcnAll$meta[,.(x=paste(livPD,columbiaPD,harvardPD))]$x #modules conserved in the 4 pm networks and the liv PD network

# DEFINE - conserved modules that are specific to PD in PM samples
  mcnPpd$meta[,inPmAll:=FALSE]
  mcnPpd$meta[,inPdAll:=FALSE]
  mcnPpd$meta[paste(columbiaPD,harvardPD) %in% pmall,inPmAll:=TRUE]
  mcnPpd$meta[paste(columbiaPD,harvardPD) %in% pdall,inPdAll:=TRUE]
  pmpdConMod <- mcnPpd$meta[inPmAll==FALSE & inPdAll==FALSE][,.(columbiaPD,harvardPD,module=paste0("pmmodule",.I))]

# DEFINE - conserved modules that are specific to PD in LIV samples
  lvpd <- unique(cenList$livPD$module)
  lvpdall <- mcnPkd$meta$livPD
  lvlvcon <- mcnLcn$meta$livPD
  lvpdunq <- lvpd[!lvpd %in% c(lvpdall, lvlvcon)]

# DEFINE - conserved modules that are specific to PD (in LIV and PM together)
  mcnPkd$meta[,inAll5:=FALSE]
  mcnPkd$meta[paste(livPD,columbiaPD,harvardPD) %in% inal5, inAll5:=TRUE]
  livpmpdmod <- mcnPkd$meta[inAll5==FALSE][,.(livPD,columbiaPD,harvardPD,module=paste0("livpmmodule",.I))]

# organize living and pm modules to test for enrichment of deg and gwas
  mcnEnrichInput <- list("livPD"=lvpdunq, "harvardPD"=pmpdConMod$harvardPD, "columbiaPD"=pmpdConMod$columbiaPD)
  mcnEnrichInput$livPD <- c(mcnEnrichInput$livPD, livpmpdmod$livPD)
  mcnEnrichInput$harvardPD <- c(mcnEnrichInput$harvardPD, livpmpdmod$harvardPD)
  mcnEnrichInput$columbiaPD <- c(mcnEnrichInput$columbiaPD, livpmpdmod$columbiaPD)

# gene sets to test for enrichment 

  ## pd genetics
  pdgwas <- fread("/sc/arion/projects/psychgen/lbp/files/nalis2019_pd_gwas_78_nearest_genes.tsv")
  map <- fread("~/gene_ids_ensembl2symbol_fromHUGO_10JUN2020.tsv", na=c("","NA"), col.names=c("symbol", "gene"))
  pdGws <- merge(pdgwas, map)[!is.na(gene)]$gene

# enrichment of conserved modules for pd gwas and pd pm deg
  realbb <- cenList[[1]][,.(gene, module=0, gwas=0)]                            
  realbb[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1L)]
  realbb[gene %in% pdGws, gwas:=1]
  iterCol <- colnames(realbb)[3:ncol(realbb)]
  mcnEnrich <- c()
  lbppdOlap <- list()
  for (i in names(mcnEnrichInput)){
      print(i)
      lbppdOlap[[i]] <- list()
      curMls <- mcnEnrichInput[[i]]      
      curNet <- cenList[[i]]      
      curNet[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1L)]
      for (j in curMls){
          cur <- copy(realbb)
          mdg <- curNet[module==j]$gene
          cur[gene %in% mdg, module:=1]
          for (k in iterCol){
              myfish <- fisher.test(table(cur[["module"]], cur[[k]]), alternative="greater")
              s1 <- nrow(cur[module==1])
              s2 <- nrow(cur[get(k)==1])
              s3 <- nrow(cur[module==1 & get(k)==1])
              add <- data.table( cen=i, module=j, set=k, moduleSize=s1, setSize=s2, overlapSize=s3, or=myfish$estimate, p=myfish$p.value )
              mcnEnrich <- rbind(mcnEnrich, add)
              if (i == "livPD" & k %in% c("phup", "pcup")){
                  k2 <- paste0(k,2)
                  s4 <- length(cur[module==1 & get(k2)==1]$gene)
                  s5 <- length(cur[module==1 & get(k)==1 & pm==1]$gene)
                  if(s3-s4 != s5) print("ERROR: the math for checking module/lbp/pd overlap counts doesnt check out")
                  lbppdOlap[[paste(j, k)]] <- cur[module==1 & get(k)==1 & pm==1]$gene
              } else if (i == "livPD" & k %in% c("phdw", "pcdw")){
                  k2 <- paste0(k,2)
                  s4 <- length(cur[module==1 & get(k2)==1]$gene)
                  s5 <- length(cur[module==1 & get(k)==1 & living==1]$gene)
                  if(s3-s4 != s5) print("ERROR: the math for checking module/lbp/pd overlap counts doesnt check out")
                  lbppdOlap[[paste(j, k)]] <- cur[module==1 & get(k)==1 & living==1]$gene
              }
          }
      }
  }
  mcnEnrich[cen=="livPD" & module %in% lvpdunq, masterCategory:="LIV_PD_ONLY"]
  mcnEnrich[cen=="harvardPD" & module %in% pmpdConMod$harvardPD, masterCategory:="PM_PD_ONLY"]
  mcnEnrich[cen=="columbiaPD" & module %in% pmpdConMod$columbiaPD, masterCategory:="PM_PD_ONLY"]
  mcnEnrich[cen=="livPD" & module %in% livpmpdmod$livPD, masterCategory:="LIV_AND_PM_PD"]
  mcnEnrich[cen=="harvardPD" & module %in% livpmpdmod$harvardPD, masterCategory:="LIV_AND_PM_PD"]
  mcnEnrich[cen=="columbiaPD" & module %in% livpmpdmod$columbiaPD, masterCategory:="LIV_AND_PM_PD"]
  mcnEnrich2 <- c()
  iter <- mcnEnrich[,.N,list(cen,masterCategory)]
  for (i in 1:nrow(iter)){
      net <- iter[i]$cen
      dss <- iter[i]$masterCategory
      add <- mcnEnrich[cen==net & masterCategory==dss]
      add[,padj:=p.adjust(p,"fdr")]
      mcnEnrich2 <- rbind(mcnEnrich2, add)
  }
x1 <- pmpdConMod[,.(cen="columbiaPD", module=columbiaPD, conmodule=module)]
  x2 <- pmpdConMod[,.(cen="harvardPD", module=harvardPD, conmodule=module)]
  x3 <- unique(mcnEnrich2[cen=="livPD" & masterCategory=="LIV_PD_ONLY",.(cen,module)])[,.(cen,module,conmodule=paste0("lvmodule",.I))]
  x4 <- livpmpdmod[,.(cen="columbiaPD", module=columbiaPD, conmodule=module)]
  x5 <- livpmpdmod[,.(cen="harvardPD", module=harvardPD, conmodule=module)]
  x6 <- livpmpdmod[,.(cen="livPD", module=livPD, conmodule=module)]
  mcnEnrich2 <- merge(mcnEnrich2, rbind(x1,x2,x3,x4,x5,x6))
  saveRDS(mcnEnrich2, file="/sc/arion/projects/psychgen/lbp/results/lel2021_pdModuleEnrichments_07DEC2021.RDS")
  ##mcnEnrich2 <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_pdModuleEnrichments_07DEC2021.RDS")

# gwas enrichment plot
   
  ## subset modules to plot (liv - or>0, pm - or in pm1 and pm2 > 0, livpm - or in liv pm1 pm2 > 0)
  livkeep <- mcnEnrich2[masterCategory=="LIV_PD_ONLY"][or>0]$conmodule
  pmkeep <- mcnEnrich2[masterCategory=="PM_PD_ONLY"][or>0][,.N,conmodule][N==2]$conmodule
  livpmkeep <- mcnEnrich2[masterCategory=="LIV_AND_PM_PD"][or>0][,.N,conmodule][N==3]$conmodule
  plotmods <- c(livkeep,pmkeep,livpmkeep)
  plotdata <- copy(mcnEnrich2)
  plotdata[,plotme:=FALSE]
  plotdata[conmodule %in% plotmods,plotme:=TRUE]

  ## make network names pretty
  plotdata[cen=="livPD",cen:="LVPD"]
  plotdata[cen=="harvardPD",cen:="PM1PD"]
  plotdata[cen=="columbiaPD",cen:="PM2PD"]
  plotdata[,cen:=factor(cen, levels=c("LVPD", "PM1PD", "PM2PD"))]

  ## indicate living vs postmortem modules
  plotdata[masterCategory=="LIV_PD_ONLY", `Conserved Module Class`:="Living"]
  plotdata[masterCategory=="PM_PD_ONLY",`Conserved Module Class`:="Postmortem"]
  plotdata[masterCategory=="LIV_AND_PM_PD",`Conserved Module Class`:="Living and Postmortem"]
  plotdata[,`Conserved Module Class`:=factor(`Conserved Module Class`, levels=c("Living", "Postmortem", "Living and Postmortem"))]

  ## make module names pretty
  plotdata[,`Conserved Module Index`:=conmodule]
  plotdata[,`Conserved Module Index`:=gsub("livpmmodule", "", `Conserved Module Index`)]
  plotdata[,`Conserved Module Index`:=gsub("lvmodule", "", `Conserved Module Index`)]
  plotdata[,`Conserved Module Index`:=gsub("pmmodule", "", `Conserved Module Index`)]
  plotdata[,`Conserved Module Index`:=str_pad(`Conserved Module Index`, 2, pad = "0")]
  plotdata[`Conserved Module Class`=="Living",`Conserved Module Index`:=paste0("LVPD", `Conserved Module Index`)]
  plotdata[`Conserved Module Class`=="Postmortem",`Conserved Module Index`:=paste0("PMPD", `Conserved Module Index`)]
  plotdata[`Conserved Module Class`=="Living and Postmortem",`Conserved Module Index`:=paste0("LIVPMPD", `Conserved Module Index`)]

  ## indicate significance
  plotdata[p>0.05, Significance:="Insignificant"]
  plotdata[p<0.05 & padj>0.05, Significance:="Nominally Significant"]
  plotdata[padj<0.05, Significance:="Significant"]

  ## plot liv point with highest or (for consistency)
  helper <- plotdata[`Conserved Module Class`=="Living" & plotme==TRUE]
  helper <- helper[,list(or=max(or)),by=list(`Conserved Module Index`)]
  helper <- helper[,.(x=paste(`Conserved Module Index`,or))]$x
  plotdata[,plotme2:=FALSE]
  plotdata[plotme==TRUE & `Conserved Module Class`=="Living" & paste(`Conserved Module Index`,or) %in% helper, plotme2:=TRUE]

  ## plot pm point with highest or
  helper <- plotdata[`Conserved Module Class`=="Postmortem" & plotme==TRUE]
  helper <- helper[,list(or=max(or)),by=list(`Conserved Module Index`)]
  helper <- helper[,.(x=paste(`Conserved Module Index`,or))]$x
  plotdata[plotme==TRUE & `Conserved Module Class`=="Postmortem" & paste(`Conserved Module Index`,or) %in% helper, plotme2:=TRUE]

  ## plot livpm point with highest or
  helper <- plotdata[`Conserved Module Class`=="Living and Postmortem" & plotme==TRUE]
  helper <- helper[,list(or=max(or)),by=list(`Conserved Module Index`)]
  helper <- helper[,.(x=paste(`Conserved Module Index`,or))]$x
  plotdata[plotme==TRUE & `Conserved Module Class`=="Living and Postmortem" & paste(`Conserved Module Index`,or) %in% helper, plotme2:=TRUE]

  ## points by class
  plotdata[plotme2==TRUE][,.N,`Conserved Module Class`]
  ##   Conserved Module Class  N
  ##1:             Postmortem  4
  ##2:  Living and Postmortem  2
  ##3:                 Living 26

  ## save
  saveRDS(plotdata, file="/sc/arion/projects/psychgen/lbp/results/lel2021_pdModuleEnrichments_07DEC2021_FORFIGURE.RDS")

# keg enrichment for gwas enriched living pd modules
  lvpdMods <- mcnEnrich[cen=="livPD" & set=="gwas"][p<0.05]$module
  lvpdNtwk <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/cen/cen_subsets.RDS")$livPD
  lvpdGset <- lvpdNtwk[module %in% lvpdMods]$gene
  keg <- fread("/sc/arion/projects/psychgen/lbp/resources/kegg/hsa00001_noheader_PARSED_MAPPED2ENSEMBL.tsv")
  keg[,awcid:=paste(TopLevelString,SuperPathwayCode,KoReferencePathwayCode,sep="|")]
  keg.nogene <- unique(keg[,.(awcid, TopLevelString,SuperPathwayStringA,SuperPathwayStringB,KoReferencePathwayStringA)])
  kgLst <- split(unique(keg[,.(awcid,gene)]), by="awcid")
  kgLst <- lapply(kgLst, function(x) x$gene)
  bb <- lbp$livpmDE[,.(gene, deg=0)]
  bb[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1L)]
  mygwsKegEnrich <- c()
  for (i in lvpdMods){
      cur <- copy(bb)
      mdg <- cenList[["livPD"]][module==i]$gene
      cur[gene %in% mdg, deg:=1]
      x <- runKegg(cur, i, kgLst)
      x <- data.table(module=i, x )
      x[,padj:=p.adjust(pval, "fdr")]
      mygwsKegEnrich <- rbind(mygwsKegEnrich,x)
  }
  mygwsKegEnrichSig <- merge(mygwsKegEnrich[padj<0.05], keg.nogene)
  saveRDS(mygwsKegEnrichSig, file="/sc/arion/projects/psychgen/lbp/results/lel2021_pdModuleEnrichments_pgGwasEnrichedMods_Kegg_26OCT2021.RDS")


#+END_SRC

#+NAME: DONE_de_of_age_in_liv_and_pm_RUN_FULL
#+BEGIN_SRC R

# setup
  rm(list=ls())
  options(stringsAsFactors=F)
  library(data.table)
  library(ggplot2)
  library(ggthemes)
  library(ggrepel)
  library(scales)
  library(rlang)
  library(assertthat)
  library(dplyr)
  library(magrittr)
  library(stringr)
  library(grid) 
  library(gtable)
  library(gridExtra)
  library(ggpubr)
  library(extrafont) 
  library(patchwork)
  library(variancePartition)
  library(limma)
  library(edgeR)
  library(Glimma)
  library(BiocParallel)
  library(qvalue)
  Sys.setenv(OMP_NUM_THREADS = 6)
  setwd("/sc/arion/projects/psychgen/lbp/data/")

# read in lbp data
  lbp <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")
  met <- lbp$covariates
  vob <- lbp$vobjDream

# split living samples into same halves used for the bank-specific livpm de analyses
  set.seed(666)
  liv <- met[mymet_postmortem==0]$SAMPLE_ISMMS

# make de variable
  pm1 <- met[mymet_bank=="Harvard"]$SAMPLE_ISMMS
  pm2 <- met[mymet_bank=="Columbia"]$SAMPLE_ISMMS
  liv <- met[mymet_living==1]$SAMPLE_ISMMS
  met[SAMPLE_ISMMS %in% pm1, DE:="pm1"]
  met[SAMPLE_ISMMS %in% pm2, DE:="pm2"]
  met[SAMPLE_ISMMS %in% liv, DE:="liv"]

# update metadata
  met <- as.data.frame(met)
  rownames(met) <- met$SAMPLE_ISMMS

# formulas
  form1 <- ~ DE + DE:mymet_age - mymet_age + (1|mymet_phe) + (1|mymet_sex) + 
              mymet_rin + neuronal + RNASeqMetrics_MEDIAN_3PRIME_BIAS + 
              RNASeqMetrics_PCT_MRNA_BASES + (1|IID_ISMMS) + (1|mymet_depletionbatch) + 
              InsertSizeMetrics_MEDIAN_INSERT_SIZE + AlignmentSummaryMetrics_STRAND_BALANCE_FIRST_OF_PAIR
  form2 <- ~0 + mymet_age*mymet_postmortem + mymet_rin + neuronal + RNASeqMetrics_MEDIAN_3PRIME_BIAS + (1|mymet_phe) + (1|mymet_sex) +
              RNASeqMetrics_PCT_MRNA_BASES + (1|IID_ISMMS) + (1|mymet_depletionbatch) + 
              InsertSizeMetrics_MEDIAN_INSERT_SIZE + AlignmentSummaryMetrics_STRAND_BALANCE_FIRST_OF_PAIR

# dream - individual datasets
  fitmm1 <- dream( vob, form1, met, BPPARAM = MulticoreParam(5) )
  livAgeDe <- topTable( fitm1x, coef="DEliv:mymet_age", number=nrow(vob) )
  pm1AgeDe <- topTable( fitmm1, coef="DEpm1:mymet_age", number=nrow(vob) )
  pm2AgeDe <- topTable( fitmm1, coef="DEpm2:mymet_age", number=nrow(vob) )
  livAgeDe <- data.table( gene = rownames(livAgeDe), livAgeDe )
  pm1AgeDe <- data.table( gene = rownames(pm1AgeDe), pm1AgeDe )
  pm2AgeDe <- data.table( gene = rownames(pm2AgeDe), pm2AgeDe )

# dream - interaction
  fitmm2 <- dream( vob, form2, met, BPPARAM = MulticoreParam(5) )
  intAgeDe <- topTable( fitmm2, coef="mymet_age:mymet_postmortem", number=nrow(vob) )
  intAgeDe <- data.table( gene = rownames(intAgeDe), intAgeDe )

# save
  saveRDS(list("liv"=livAgeDe, "lv1"=lv1AgeDe, "lv2"=lv2AgeDe, "pm1"=pm1AgeDe, "pm2"=pm2AgeDe, "interaction"=intAgeDe), 
               file="/sc/arion/projects/psychgen/lbp/results/lel2021_livpmageInteraction_01DEC2021.RDS")

#+END_SRC

#+NAME: DONE_de_of_age_in_liv_and_pm_RUN_PERMUTATIONS
#+BEGIN_SRC shell

# setup 
  module load R/4.0.3
  RSCRIPT=/sc/arion/work/charna02/scripts/lbp/liharska2021_livpm_age_de_perms.r
  SCRATCH=/sc/arion/projects/psychgen/lbp/scratch/lel2021_livpm_age_de_perms

# send jobs
  cd ${SCRATCH}
  for i in {1..2000}
  do mybsub psychgen seed${i} 5000 1:00 premium 5 "Rscript ${RSCRIPT} ${i} ${SCRATCH}/seed${i}.RDS"
  done

# check 
  cd ${SCRATCH}
  ls seed*stdout | sort | uniq  > sent
  grep Success seed*stdout | awk -F":" '{print $1}' | sort | uniq > success
  comm -23 sent success | sort | uniq > fail
  wc -l sent success fail
  ##2000 sent
  ##1998 success
  ##   2 fail

# rerun fail
  cd ${SCRATCH}
  for x in `cat fail`
  do
    i=`echo ${x} | awk -F"." '{print $1}' | sed s/seed//g`
    mybsub psychgen seed${i} 5000 1:00 premium 5 "Rscript ${RSCRIPT} ${i} ${SCRATCH}/seed${i}.RDS"
  done

#+END_SRC

#+NAME: DONE_make_figure
#+BEGIN_SRC R

# setup 
  rm(list=ls())
  library(data.table)
  library(ggplot2)
  library(ggthemes)
  library(ggrepel)
  library(scales)
  library(rlang)
  library(assertthat)
  library(dplyr)
  library(magrittr)
  library(stringr)
  library(grid) 
  library(gtable)
  library(gridExtra)
  library(ggpubr)
  library(extrafont) 
  library(patchwork)
  loadfonts(quiet=T)

# session info
  sessionInfo()

# part A data - de results
  #de <- readRDS("/sc/arion/work/charna02/symlinks/lbp/liharska2021/final.everything.RDS")$livpmDE  
  de <- readRDS("/sc/arion/projects/psychgen2/lbp/data/RAW/rna/bulk/fromSema4/CompiledData/lbp_allBatches_RAPiD_Covs-featureCounts-vobjDream-Resids-LivPmDE_FINALModel_onlyBRAIN_518Samples_Excluding-Outliers-MislabeledSamples-BadSamples_19JUL2021.RDS")$livpmDE
  de[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  de[,de.status := "Not DE"]
  de[DEG=="DEG" & LFC=="POSLFC", de.status:="Postmortem"]
  de[DEG=="DEG" & LFC=="NEGLFC", de.status:="Living"]
  de[,de.status:=factor(de.status,levels=c("Postmortem", "Living", "Not DE"))]
  table(de$de.status)
  ##
  ##  Living     Not DE Postmortem 
  ##    9198       4449       7988 

  ## lbp by bank
  mybk1 <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_bank_14OCT2021.RDS")$LIVPMDE_HAR
  mybk2 <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpm_bank_14OCT2021.RDS")$LIVPMDE_COL
  mybk1[,de.status := "Not DE"]
  mybk2[,de.status := "Not DE"]
  mybk1[DEG=="DEG" & LFC=="POSLFC", de.status:="Postmortem"]
  mybk2[DEG=="DEG" & LFC=="POSLFC", de.status:="Postmortem"]
  mybk1[DEG=="DEG" & LFC=="NEGLFC", de.status:="Living"]
  mybk2[DEG=="DEG" & LFC=="NEGLFC", de.status:="Living"]
  mybk1[,de.status:=factor(de.status,levels=c("Postmortem", "Living", "Not DE"))]
  mybk2[,de.status:=factor(de.status,levels=c("Postmortem", "Living", "Not DE"))]

  ## alz and scz de results
  az1raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_alz1_de_results.RDS") #msbb
  az2raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_alz2_de_results.RDS") #rosmap
  sz1raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_scz1_de_results.RDS") #hbcc
  sz2raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_scz2_de_results.RDS") #cmc
  pd1raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_pmpd_bank_22OCT2021.RDS")$PMPDDE_HAR
  pd2raw <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_pmpd_bank_22OCT2021.RDS")$PMPDDE_COL
  az1 <- merge(az1raw, de[,.(gene,lbp=logFC, lbp.status=de.status)], by="gene")
  az2 <- merge(az2raw, de[,.(gene,lbp=logFC, lbp.status=de.status)], by="gene")
  sz1 <- merge(sz1raw, de[,.(gene,lbp=logFC, lbp.status=de.status)], by="gene")
  sz2 <- merge(sz2raw, de[,.(gene,lbp=logFC, lbp.status=de.status)], by="gene")
  pd1 <- merge(pd1raw, mybk2[,.(gene,lbp=logFC, lbp.status=de.status)], by="gene")
  pd2 <- merge(pd2raw, mybk1[,.(gene,lbp=logFC, lbp.status=de.status)], by="gene")
  az1[,az1.status:="Not DE"]
  az2[,az2.status:="Not DE"]
  sz1[,sz1.status:="Not DE"]
  sz2[,sz2.status:="Not DE"]
  pd1[,pd1.status:="Not DE"]
  pd2[,pd2.status:="Not DE"]
  az1[adj.P.Val<0.05 & logFC>0, az1.status:="Up in ALZ1"]
  az2[adj.P.Val<0.05 & logFC>0, az2.status:="Up in ALZ2"]
  sz1[adj.P.Val<0.05 & logFC>0, sz1.status:="Up in SCZ1"]
  sz2[adj.P.Val<0.05 & logFC>0, sz2.status:="Up in SCZ2"]
  pd1[adj.P.Val<0.05 & logFC>0, pd1.status:="Up in PD1"]
  pd2[adj.P.Val<0.05 & logFC>0, pd2.status:="Up in PD2"]
  az1[adj.P.Val<0.05 & logFC<0, az1.status:="Up in CTRL"]
  az2[adj.P.Val<0.05 & logFC<0, az2.status:="Up in CTRL"]
  sz1[adj.P.Val<0.05 & logFC<0, sz1.status:="Up in CTRL"]
  sz2[adj.P.Val<0.05 & logFC<0, sz2.status:="Up in CTRL"]
  pd1[adj.P.Val<0.05 & logFC<0, pd1.status:="Up in CTRL"]
  pd2[adj.P.Val<0.05 & logFC<0, pd2.status:="Up in CTRL"]
  az1[, nlogp:=-log10(adj.P.Val)]
  az2[, nlogp:=-log10(adj.P.Val)]
  sz1[, nlogp:=-log10(adj.P.Val)]
  sz2[, nlogp:=-log10(adj.P.Val)]
  pd1[, nlogp:=-log10(adj.P.Val)]
  pd2[, nlogp:=-log10(adj.P.Val)]

  ### age de results
  livAgeDe <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpmageInteraction_01DEC2021.RDS")$liv
  pm1AgeDe <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpmageInteraction_01DEC2021.RDS")$pm1
  pm2AgeDe <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_livpmageInteraction_01DEC2021.RDS")$pm2
  livAgeDe[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  pm1AgeDe[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  pm2AgeDe[,gene:=tstrsplit(gene, split=".", fixed=T, keep=1)]
  livAgeDe2 <- merge(livAgeDe, de[,.(gene,lbp=logFC, lbp.status=de.status)], by="gene")
  pm1AgeDe2 <- merge(pm1AgeDe, de[,.(gene,lbp=logFC, lbp.status=de.status)], by="gene")
  pm2AgeDe2 <- merge(pm2AgeDe, de[,.(gene,lbp=logFC, lbp.status=de.status)], by="gene")
  livAgeDe2[,liv.status:="Not DE"]
  pm1AgeDe2[,pm1.status:="Not DE"]
  pm2AgeDe2[,pm2.status:="Not DE"]
  livAgeDe2[adj.P.Val<0.05 & logFC>0, liv.status:="Up in LIV Age"]
  livAgeDe2[adj.P.Val<0.05 & logFC<0, liv.status:="Down in LIV Age"]
  pm1AgeDe2[adj.P.Val<0.05 & logFC>0, pm1.status:="Up in PM Age"]
  pm1AgeDe2[adj.P.Val<0.05 & logFC<0, pm1.status:="Down in PM Age"]
  pm2AgeDe2[adj.P.Val<0.05 & logFC>0, pm2.status:="Up in PM Age"]
  pm2AgeDe2[adj.P.Val<0.05 & logFC<0, pm2.status:="Down in PM Age"]
  livAgeDe2[, nlogp:=-log10(adj.P.Val)]
  pm1AgeDe2[, nlogp:=-log10(adj.P.Val)]
  pm2AgeDe2[, nlogp:=-log10(adj.P.Val)]

  ## part A - alz1  
  my_custom_labelsx = c("0","","2","","4")        
  my_custom_labels = c("-0.04","","0","","0.04")        
  partA_AZ1 <- ggscatter(az1, x = "logFC", y = "nlogp", size=0.001, alpha=0.7) + 
          geom_rug(sides="b", aes(col=lbp.status, alpha=abs(lbp)), length = unit(0.33, "npc")) +
          scale_color_manual(values=c("#2cace2", "#d80f8c", "#999999")) + 
          scale_y_continuous(expand = expansion(mult = c(0.5, 0)), breaks=c(0, 1, 2, 3, 4), labels = my_custom_labelsx) +
          geom_hline(yintercept=-log10(0.05), lty="dotted", col="red") + ggtitle("ALZ1") + 
          theme(legend.position="none", 
                axis.title.y = element_blank(),
                axis.title.x = element_blank(), 
                text=element_text(family="Arial", size=12)) +
          scale_x_continuous(labels = my_custom_labels)

  ## part A - alz2
  x1b_y_labels = c("0", "3", "6")
  x1b_x_labels = c("-0.5", "0", "0.5", "1")
  partA_AZ2 <- ggscatter(az2, x = "logFC", y = "nlogp", size=0.001, alpha=0.7) + 
          geom_rug(sides="b", aes(col=lbp.status, alpha=abs(lbp)), length = unit(0.33, "npc")) +
          scale_color_manual(values=c("#2cace2", "#d80f8c", "#999999")) + 
          scale_y_continuous(expand = expansion(mult = c(0.5, 0)), breaks=c(0, 3, 6), labels = x1b_y_labels) +
          geom_hline(yintercept=-log10(0.05), lty="dotted", col="red") + ggtitle("ALZ2") + 
          theme(legend.position="none", 
                axis.title.y = element_blank(),
                axis.title.x = element_blank(), 
                text=element_text(family="Arial", size=12)) +
          scale_x_continuous(breaks = c(-0.5, 0, 0.5, 1), labels = x1b_x_labels)

  ## part A - scz1
  x2a_y_labels = c("0", "3", "6")
  x2a_x_labels = c("-0.5", "0", "0.5", "1")          
  partA_SZ1 <- ggscatter(sz1, x = "logFC", y = "nlogp", size=0.001, alpha=0.7) + 
          geom_rug(sides="b", aes(col=lbp.status, alpha=abs(lbp)), length = unit(0.33, "npc")) +
          scale_color_manual(values=c("#2cace2", "#d80f8c", "#999999")) + 
          scale_y_continuous(expand = expansion(mult = c(0.5, 0)), breaks=c(0, 3, 6), labels = x2a_y_labels) +
          geom_hline(yintercept=-log10(0.05), lty="dotted", col="red") + ggtitle("SCZ1") + 
          theme(legend.position="none", 
                axis.title.y = element_blank(),
                axis.title.x = element_blank(), 
                text=element_text(family="Arial", size=12)) +
          scale_x_continuous(breaks = c(-0.5, 0, 0.5, 1), labels = x2a_x_labels)

  ## part A - scz2
  x2b_y_labels = c("0", "", "1", "", "2", "")
  x2b_x_labels = c("-0.8", "-0.4", "0", "0.4")
  partA_SZ2 <- ggscatter(sz2, x = "logFC", y = "nlogp", size=0.001, alpha=0.7) + 
          geom_rug(sides="b", aes(col=lbp.status, alpha=abs(lbp)), length = unit(0.33, "npc")) +
          scale_color_manual(values=c("#2cace2", "#d80f8c", "#999999")) + 
          scale_y_continuous(expand = expansion(mult = c(0.5, 0)), breaks=c(0, 0.5, 1, 1.5, 2, 2.5), labels = x2b_y_labels) +
          geom_hline(yintercept=-log10(0.05), lty="dotted", col="red") + ggtitle("SCZ2") + 
          theme(legend.position="none", 
                axis.title.y = element_blank(),
                axis.title.x = element_blank(), 
                text=element_text(family="Arial", size=12)) +
          scale_x_continuous(breaks = c(-0.8, -0.4, 0, 0.4), labels = x2b_x_labels)

  ## part A - pd1
  x3a_y_labels = c("0", "6", "12")
  x3a_x_labels = c("-2", "0", "2")          
  partA_PD1 <- ggscatter(pd1, x = "logFC", y = "nlogp", size=0.001, alpha=0.7) + 
          geom_rug(sides="b", aes(col=lbp.status, alpha=abs(lbp)), length = unit(0.33, "npc")) +
          scale_color_manual(values=c("#2cace2", "#d80f8c", "#999999")) + 
          scale_y_continuous(expand = expansion(mult = c(0.5, 0)), breaks=c(0, 6, 12), labels = x3a_y_labels) +
          geom_hline(yintercept=-log10(0.05), lty="dotted", col="red") + ggtitle("PD1") + 
          theme(legend.position="none", 
                axis.title.y = element_blank(),
                axis.title.x = element_blank(), 
                text=element_text(family="Arial", size=12)) +
          scale_x_continuous(breaks = c(-2, 0, 2), labels = x3a_x_labels)

  ## part A - pd2
  x3b_y_labels = c("0", "", "3", "", "6")
  x3b_x_labels = c("-1", "0", "1")
  partA_PD2 <- ggscatter(pd2, x = "logFC", y = "nlogp", size=0.001, alpha=0.7) + 
          geom_rug(sides="b", aes(col=lbp.status, alpha=abs(lbp)), length = unit(0.33, "npc")) +
          scale_color_manual(values=c("#2cace2", "#d80f8c", "#999999")) + 
          scale_y_continuous(expand = expansion(mult = c(0.5, 0)), breaks=c(0, 1.5, 3, 4.5, 6), labels = x3b_y_labels) +
          geom_hline(yintercept=-log10(0.05), lty="dotted", col="red") + ggtitle("PD2") + 
          theme(legend.position="none", 
                axis.title.y = element_blank(),
                axis.title.x = element_blank(), 
                text=element_text(family="Arial", size=12)) +
          scale_x_continuous(breaks = c(-1, 0, 1), labels = x3b_x_labels)

  ## part A - liv
  x4a_y_labels = c("0", "5")
  x4a_x_labels = c("-0.03", "0", "0.03")
  partA_LIV <- ggscatter(livAgeDe2[nlogp<6], x = "logFC", y = "nlogp", size=0.001, alpha=0.7) + 
          geom_rug(sides="b", aes(col=lbp.status, alpha=abs(lbp)), length = unit(0.33, "npc")) +
          scale_color_manual(values=c("#2cace2", "#d80f8c", "#999999")) + 
          scale_y_continuous(expand = expansion(mult = c(0.5, 0)), breaks=c(0, 5), labels = x4a_y_labels) +
          geom_hline(yintercept=-log10(0.05), lty="dotted", col="red") + ggtitle("LIV Age") + 
          theme(legend.position="none", 
                axis.title.y = element_blank(),
                axis.title.x = element_blank(), 
                panel.background = element_rect(fill='cornsilk'),
                text=element_text(family="Arial", size=12)) + 
          scale_x_continuous(breaks = c(-0.03, 0, 0.03), labels = x4a_x_labels)

  ## part A - pm1
  x4b_y_labels = c("0", "2", "4")
  x4b_x_labels = c("-0.05", "0", "0.05")
  partA_PM1 <- ggscatter(pm1AgeDe2, x = "logFC", y = "nlogp", size=0.001, alpha=0.7) + 
          geom_rug(sides="b", aes(col=lbp.status, alpha=abs(lbp)), length = unit(0.33, "npc")) +
          scale_color_manual(values=c("#2cace2", "#d80f8c", "#999999")) + 
          scale_y_continuous(expand = expansion(mult = c(0.5, 0)), breaks=c(0, 2, 4), labels = x4b_y_labels) +
          geom_hline(yintercept=-log10(0.05), lty="dotted", col="red") + ggtitle("PM1 Age") + 
          theme(legend.position="none", 
                axis.title.y = element_blank(),
                axis.title.x = element_blank(), 
                panel.background = element_rect(fill='cornsilk'),
                text=element_text(family="Arial", size=12)) +
          scale_x_continuous(breaks = c(-0.05, 0, 0.05), labels = x4b_x_labels)

  ## part A - pm2
  x4c_y_labels = c("0", "3")
  x4c_x_labels = c("-0.05", "0", "0.05")
  partA_PM2 <- ggscatter(pm2AgeDe2, x = "logFC", y = "nlogp", size=0.001, alpha=0.7) + 
          geom_rug(sides="b", aes(col=lbp.status, alpha=abs(lbp)), length = unit(0.33, "npc")) +
          scale_color_manual(values=c("#2cace2", "#d80f8c", "#999999")) + 
          scale_y_continuous(expand = expansion(mult = c(0.5, 0)), breaks=c(0, 3), labels = x4c_y_labels) +
          geom_hline(yintercept=-log10(0.05), lty="dotted", col="red") + ggtitle("PM2 Age") + 
          theme(legend.position="none", 
                axis.title.y = element_blank(),
                axis.title.x = element_blank(), 
                panel.background = element_rect(fill='cornsilk'),
                text=element_text(family="Arial", size=12)) +
          scale_x_continuous(breaks = c(-0.05, 0, 0.05), labels = x4c_x_labels)

  ## part A - combine
  partA_layout <- c(
      area(1,1,2,6),
      area(3,1,4,6), 
      area(5,1,6,6) )
  partA_ROW1 <- (partA_AZ1|partA_AZ2|partA_PM1)
  partA_ROW2 <- (partA_SZ1|partA_SZ2|partA_PM2)
  partA_ROW3 <- (partA_PD1|partA_PD2|partA_LIV)
  PW_partA <- partA_ROW1 / partA_ROW2 / partA_ROW3 + plot_layout(design = partA_layout)
  PW_partA_gt <- patchwork::patchworkGrob(PW_partA)
  PW_partA_gt <- gridExtra::grid.arrange( PW_partA_gt, 
                                left = textGrob(expression(-log[10](p-value)), 
                                                vjust=0.9, 
                                                rot=90, 
                                                gp=gpar(fontsize=16, 
                                                        fontfamily="Arial")), 
                                bottom = textGrob("logFC", 
                                                  gp=gpar(fontsize=16, 
                                                          fontfamily="Arial"), vjust=-0.1) )
  ggsave(filename = "~/www/figures/lbp/lel2021_PRODUCTION/FORSUBMISSION/FIGURE4A.tiff", 
         plot = PW_partA_gt, width=8, height = 8, device='tiff', dpi=400)

  ## part b
  fList <- Sys.glob("/sc/arion/projects/psychgen/lbp/scratch/lel2021_livpm_age_de_perms/seed*RDS")
  mypi1 <- c()
  myrho <- c()
  for (i in fList){
      cur.name <- gsub(".RDS","",basename(i))
      add1 <- data.table(as.data.frame(readRDS(i)$pi1), keep.rownames="set")
      add2 <- data.table(as.data.frame(readRDS(i)$rho), keep.rownames="set")
      add2[,c("set1", "set2"):=tstrsplit(set, ".", fixed=TRUE)]
      add2[,set:=NULL]
      colnames(add1) <- c("set", "pi1")
      colnames(add2) <- c("rho", "set1", "set2")
      add1$seed <- cur.name
      add2$seed <- cur.name
      add1 <- add1[,.(seed, set, pi1)]
      add2 <- add2[,.(seed, set1, set2, rho)]
      mypi1 <- rbind(mypi1, add1)
      myrho <- rbind(myrho, add2)
  }
  livSet <- c("lv1", "lv2")
  pm1Set <- c("p1a", "p1b")
  pm2Set <- c("p2a", "p2b")
  mypi1[set %in% livSet, category:="LIV"]
  mypi1[set %in% pm1Set, category:="PM1"]
  mypi1[set %in% pm2Set, category:="PM2"]
  myrho[set1 %in% livSet, category1:="LIV"]
  myrho[set2 %in% livSet, category2:="LIV"]
  myrho[set1 %in% pm1Set, category1:="PM1"]
  myrho[set2 %in% pm1Set, category2:="PM1"]
  myrho[set1 %in% pm2Set, category1:="PM2"]
  myrho[set2 %in% pm2Set, category2:="PM2"]
  myrho[, comparison:=paste(category1, category2, sep="-")]
  myrho[comparison %in% c("PM1-PM1", "PM2-PM2", "PM1-PM2", "LIV-LIV"), comparisonType:="LIV-LIV or PM-PM"]
  myrho[comparison %in% c("PM1-LIV", "PM2-LIV"), comparisonType:="LIV-PM"]
  myrho <- merge(myrho, mypi1[,.(seed,set1=set,set1pi1=pi1)]) 
  myrho <- merge(myrho, mypi1[,.(seed,set2=set,set2pi1=pi1)], by=c("seed","set2"))
  myrho[comparison == "PM1-LIV", comparison:="LIV-PM1"]
  myrho[comparison == "PM2-LIV", comparison:="LIV-PM2"]
  myrho[,comparison2:=gsub("1|2","",comparison)]
  myrho[,comparison2:=factor(comparison2, levels=c("LIV-LIV", "PM-PM", "LIV-PM"))]
  myrho[,comparison:=factor(comparison, levels=c("LIV-LIV", "PM2-PM2",  "PM1-PM2", "PM1-PM1", "LIV-PM2", "LIV-PM1"))]
  plotdataX <- readRDS("/sc/arion/projects/psychgen/lbp/results/lel2021_pdModuleEnrichments_07DEC2021_FORFIGURE.RDS")
  plotdataX2 <- plotdataX[plotme2==TRUE][order(`Conserved Module Class`, -or)]
  plotdataX3 <- plotdataX2[!(`Conserved Module Class`=="Living" & Significance=="Insignificant")]
  mysize <- rep(0, nrow(plotdataX3))
  names(mysize) <- plotdataX3$Significance
  mysize[names(mysize) == "Insignificant"] <- 3
  mysize[names(mysize) == "Nominally Significant"] <- 7
  mysize[names(mysize) == "Significant"] <- 11
  mytcol <- rep("#2cace2", nrow(plotdataX3))
  names(mytcol) <- plotdataX3$`Conserved Module Class`
  mytcol[names(mytcol) == "Living"]  <- "#d80f8c"
  mytcol[names(mytcol) == "Living and Postmortem"]  <- "#1C1D6A"
  partB <- ggplot(myrho, aes(comparison, rho, fill=comparison)) + 
               geom_violin(alpha=0.2) + 
               geom_boxplot(width=0.25, notch=TRUE, alpha=0.5) + 
               scale_fill_manual(values=c("#d80f8c", "#2cace2", "#2cace2", "#2cace2", "#1C1D6A", "#1C1D6A")) +
               ylab(expression("Spearman's"~rho))+
               theme_base() + 
               theme(legend.position = "none", 
                     axis.title.x=element_blank(),
                     axis.line = element_line(),
                     text=element_text(family="Arial", size=16), 
                     axis.text.x = element_text(size=16, angle=45, hjust=1),
                     axis.text.y = element_text(size=16),
                     panel.grid.major = element_blank(),
                     panel.grid.minor = element_blank(),
                     panel.border = element_blank(),
                     panel.background = element_blank(),
                     plot.background = element_rect(color = NA)
               )
  partC <- ggdotchart(plotdataX3, x = "Conserved Module Index", y = "or",
                  color = "Conserved Module Class",
                  palette = c("#d80f8c", "#2cace2", "#1C1D6A"),
                  sorting = "descending",
                  xlab = "PD Structure",
                  ylab = "Odds Ratio",
                  x.text.col = TRUE,             
                  group="Conserved Module Class",
                  dot.size = mysize, 
                  ggtheme = theme_pubr(), 
                  add = "segments",
                  add.params = list(color = "lightgray", size = 1.75)) + ##rotate_x_text(45, vjust=1) +
            theme(legend.position="none",
                  text = element_text(size=16, family="Arial"),
                  axis.text.x = element_text(colour=mytcol, angle=45, vjust=1)) +
            scale_y_continuous(limits = c(0, 12.5), expand = c(0, 0)) 

# parts B C
  PW_partBC <- partB / partC
  ggsave(filename = "~/www/figures/lbp/lel2021_PRODUCTION/FORSUBMISSION/FIGURE4BCx.tiff", 
         plot = PW_partBC, width=5, height = 8, device='tiff', dpi=400)
 
#+END_SRC

